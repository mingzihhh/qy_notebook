### npm v1 & v2

标准包管理器，采用嵌套结构来进行版本管理

问题：

1. 项目里会反复安装相同的依赖
2. 嵌套太深会带来依赖地狱
3. 不同的项目之间会重复安装相同的包



### npm v3

```Plain
node_modules
    A@1.0
    B@1.0
    D@1.0
    C@1.0
        node_modules
            D@2.0
```

采用**扁平化**的方式，将主依赖项和子依赖都装到 node_modules 一级目录下

问题：

1. 不完全解决的重复依赖：一个包可能有多个版本，提升只能提升一个，当出现一个包有多个版本的时候，还是会出现嵌套的情况。

2. 不确定性：用户的安装顺序（install操作）可能会导致node_modules的目录结构不同，不同的成员 install 的结果不一定是一样的。A和C都依赖于D，但是版本不同，可能会出现依赖提升的版本不同。比如，A依赖于D1.0，C依赖于D2.0，如果先安装A包，D1.0就会被提升，优先安装C，D2.0就会被提升。
3. 扁平化导致的**幽灵依赖**：当我们使用提升之后，A包由于依赖于D包，我们就可以通过安装A，在项目中使用我们并没有在package.json中引入的D。那么就会导致一个问题，如果之后A不再依赖于D，D就不会被安装，我们的代码就不能跑了。



#### npm v5

吸纳了 yarn 优秀的 lock 和缓存机制，解决了不确定性的问题，提升了安装速度



#### npm v7

支持 workspace





 **npm install 的时候发生了什么**

执行 npm install 的时候会检查项目中有没有 package-lock.json 文件，有则检查 package-lock.json 文件和 package.json 文件的依赖声明版本是否一致。如果没有 package-lock.json 文件，则会根据 package.json 文件递归构建依赖树，然后按照构建好的依赖树下载完整的依赖资源。

关键在构建依赖树的时候，会遵循**扁平化**的原则，无论是直接依赖还是子依赖的依赖，都优先将其放在 `node_modules` 根目录下。在这个过程中遇到相同的依赖时，会先判断已经放置在依赖数中的依赖版本是否符合新模块对依赖版本的要求，如果符合就将其丢弃，不符合则在新模块的 `node_modules` 目录下放置该依赖。

