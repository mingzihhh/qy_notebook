**提升缓存率**

前端页面依赖的静态资源一般都会选择部署到 CDN 上，在 HTML 中通过链接加载，而静态资源链接中除了固定的前缀，文件名是通过编译工具生成的 hash 字符串。只要这个 hash 值不变，用户二次访问页面就会命中强缓存，从而提升页面性能。

然而，项目是定期迭代的，每次迭代都会改动代码，如果不妥当的组织编译产物、合理拆包，文件的 hash 就会发生变化，那么文件的缓存就会失效，从用户视角来看，每次迭代发布后页面渲染会变慢；从大盘数据来看，每次迭代发布后 LCP 会在当天劣化，随后几天回升至环比水平线。这就是缓存率下降导致的问题。

**减少冗余资源**

随着项目的不断迭代，冗余静态资源会逐渐增加，虽然 HTTP2 有多路复用的特性，但受限于带宽限制，以及增量用户的首次访问无缓存场景，冗余资源应该被清理，存在以下几类冗余资源：

- **Npm** **重复包：**产物中中存在大量相同包名却不同版本的包，尽量统一版本，减少 chunk 大小
- **Initial Chunk**：Initial Chunk 为页面首屏依赖的静态资源，它们不应该包含异步 chunk
- **Link preload：**部分预加载资源已经不再使用，可以删除，为其他必要资源让路



### **阻塞渲染的 JS 和 CSS 资源**

-  webpack-bundlle-analyzer：分析现有分包和依赖
- 公司内部 perfsee：打包产物分析



**消减 JS 和 CSS 体积**

1. 剔除重复第三方库

特殊情况下打包重复依赖，如项目直接/间接依赖了不同版本的同名包，结合包名，引用路径，版本号排查

2. 使用体积较小的第三方库

比如使用体积小的多的 dayjs（7.1K，gzipped 2.9K） 代替 moment.js（235.4K，gzipped 66.2K，而且不支持按需引入），或者如果只是使用小部分能力的话可以考虑自己实现

3. 按需引入

对一些功能比较全面的三方库（lodash，echarts，arco design 等），进行按需引入

4. 调试工具或者非线上依赖不打入正式包

如 vconsole 等调试工具或者测试环境特有的逻辑和依赖库，建议通过 webpack 变量进行判断，不打入正式包

5. 格式化代码

比如使用 css-minimizer-webpack-plungin 对 css 进行优化，去除css的空格，缩进或注释等字符



**合理拆包、延迟或懒加载未使用的资源**

- splitChunks，分包和加载策略与业务形态

- 相关按照功能优先级进行资源模块加载，组件懒加载（React.lazy，Loadable components）

- 涉及路由切换和多级菜单的业务：参考 remix 嵌套路由的解决方案，嵌套的目录结构对应嵌套的界面

  - 让开发更加模块化，每个路由文件可以导出一个 loader 函数，表示需要从服务端获取什么数据，这样在父路由中可以请求父路由自己的数据，在子路由中请求子路由的数据，而不是在页面最外层组件去统一获取所有的数据然后用 props 传递下去，父子路由之间更加独立。

  - 在页面请求时提前在 server 端感知要加载的组件和数据，在客户端直接渲染有数据的页面同时同步加载所需要的 js 资源

    

**关键 CSS**

CSS 是渲染阻塞资源，假如有个比较大的 css 文件这个过程耗时就比较长，而我们初始页面实际上需要的 css 样式可能并不多

使用 https://developer.chrome.com/docs/devtools/coverage?hl=zh-cn  查看未使用的 JavaScript 和 CSS

- 将首屏 CSS 作为关键 CSS 提取出来，或者内联到html 的 head 中（适合关键 css 体积较小的场景）
  - 工具参考：https://web.dev/articles/extract-critical-css?hl=zh-cn
  - webpack 手动配置首屏展示模块路径：optimization.splitChunks.cacheGroups.criticalcss
- 作为最高优先级阻塞加载，剩余 CSS 延迟或者根据分包懒加载

```
<link rel='preload' href='stylesheet.css' as='style' onload='this.rel='stylesheet''>
```



### 加速缓慢资源加载

**优化和压缩图片资源** （imagex：图片压缩，格式自适应，分辨率自适应，懒加载，稳定性布局，占位图过渡，错误兜底等）

1. 图片格式：WebP，AVIF 等现代高压缩率图片可以显著减小图片体积，但是需要考虑浏览器兼容性，比如 1.7mb PNG -> 422kb webP
2. 图片压缩：不影响图片主观画质的基础上压缩体积，调整压缩质量参数，422kb -> 111kb
3. 图片分辨率：比如在移动端显示，屏幕宽度 390px，devicePixelRatio 3，需要 1170px 的图片，111kb -> 61kb



**预加载重要资源**

```
<link rel="preload">
```

- 预加载浏览器发现较晚的资源（css 中的自定义字体，背景图等）
- 是否预加载非关键资源的标志：load 事件发生 3s 左右后，未使用的预加载会在 chrome 中触发控制台警告。



**压缩文本文件**

一般默认支持， gzip / brotil

cdn 可以根据 accept-encoding header 选择压缩算法



### 防劣化

- 打包时进行产物分析，对产物体积变化进行卡点
- 线上性能监控和巡检，配置 LCP，CLS 等指标报警
