|          | Polyrepo                                                   | Monorepo                                                     |
| -------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 基建     | 每个项目都需要有开发人员创建和维护                         | 只需要一两个人统一维护基建部分                               |
| 代码复用 | 维护公用模块的成本比较高，调试很繁琐，公用模块的升级很繁琐 | 底层模块的更改能够直接被上层感知，甚至不需要经过 link 和 npm 发布，方便复用依赖和基础配置 |
| 提交     | 需要修改多个仓库并提交多个 MR                              | 一次性调整并提交多个项目并只需要提交一个 MR                  |
| 优点     | 仓库职责单一，代码量和复杂度受控，利于权限控制             | 方便代码复用，所有项目的版本控制更加容易和一致，可以统一项目的构建和部署流程 |
| 缺点     | 代码和配置很难共享，依赖治理复杂                           | 能随着时间推移变得庞大和复杂，导致构建时间增长和管理困难，git clone、pull 的成本增加；项目粒度的权限管理比较困难 |



### 什么是Monorepo？

Monorepo是一种**代码管理模式**，将**多个项目**组织到一个Repo中。Monorepo具有如下特点：

- 子项目是独立的，可以独立开发、测试、部署
- 子项目类型可以是任意的，可以是 web 项目、server 项目或者 library 项目等
- 子项目间可能有依赖关系，例如一些顶层的项目会依赖于底层项目暴露的 API

对于前端而言，Monorepo 的子项目可以大概分为两类：

- **业务型子项目**：子项目是需要部署上线的，例如基于 React 的业务项目，该类型的子项目的特点是不不需要 publish 到 registry

- **lib 型子项目**：通常意义的前端 package，特点是需要 publish 到 npm registry。该类型 Monorepo 在开源项目中非常常见，例如 React、Vue3、npm7、Babel 等。

  

**Monorepo 与包管理工具（npm、yarn、pnpm）之间是一种怎样的关系？**

这些包管理工具与 monorepo 的关系在于，它们可以为 monorepo 提供**依赖安装与依赖管理**的支持，通过 workspace 功能来支持 Monorepo 模式，允许在 monorepo 中的不同子项目之间共享依赖项，并提供一种管理这些共享依赖项的方式，这可以简化依赖项管理和构建过程，并提高开发效率。



### Emo

字节内部 monorepo 工程化解决方案



#### 基建目录

通常 monorepo 中会存在一份全局的 package.json，用来安装一些全局用到的基建库，例如所有项目共用的 eslint 等，emo 提供 infraDir 配置项用来控制基建目录的位置，即这份 package.json 和 node_modules 的位置

##### 顶层基建模式

不指定时，基建目录位置在项目根目录

- 社区主流方式
- 存在幻影依赖问题：node 中 node_modules 逐渐向上查找依赖的 resolve 机制，子包可以蹭到顶层的 node_modules

**折叠基建模式**

指定位置后，原来存在根目录的  package.json 和 node_modules  会折叠到该目录

- 基建工具配置存在一定成本，cli 工具的安装从 node_modules/.bin 移动到 ${nfraDir}/node_modules/.bin，需要调整运行时的 cwd
  - 通过 emox：直接启用 ${nfraDir}/node_modules/.bin 下的cli 工具

- 进一步解决幻影依赖问题，避免在根目录安装任何依赖，将相关的工具依赖安装在 infra 目录中，避免相关工具链引入幻影依赖问题



#### 提供 workspace checker

规范检查工具，执行对 monorepo 的约束，包括：

- 限制特定 lib 只能被特定项目依赖
- 检查依赖版本是否统一：比如 A 使用了 react16，B 使用了 react17
- 检查是否存在幻影依赖
- 检查是否存在循环依赖

检查时机：

- 配置了 forceCheck 时，每次执行 cli 命令时检查，如果 check 不通过会打断
- emo check 命令



#### 依赖管理

- pnpm link，避免欢迎幻影依赖和分身问题；设计了**折叠基建模式**，避免在根目录安装任何依赖，进一步避免

- 本地自动链接：仓库内子项目自动链接，当子项目变动时，可以在不发布的情况下看到下游所有变化，不用手动 npm link



#### 基于源码开发



#### 快速构建

- 支持部分项目构建
- 在本地开发过程中，支持自动预购建开发项目的子依赖
- 内置**构建缓存**，没修改不会再次触发构建，按照子项目间的拓扑关系尽可能**并行构建**



#### 与内部基建深度结合

- Codebase， CI/CD
- SCM / ByteCycle / Goofy