## 埋点方案

#### what？

事件追踪（Event Tracking），它主要针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。

记录用户行为过程和结果

#### why？

通过分析埋点数据，包括访问数（Visits），访客数（Visitor），停留时长（Time On Site），页面浏览数（Page Views）和跳出率（Bounce Rate）等等：

产品/运营：

- 分析用户日活/留存/转化
- 核心转化留存分析：通过用户的操作序列/行为路径，找到用户流失的节点
- 验证新功能效果 / 营销活动 ROI
- 产品问题洞察：例如用户有没有因为设计按钮过多导致用户行为无效等问题，以此发现功能设计缺陷等
- 用户路径追踪，分析用户行为
- 完善客户画像：基本属性（性别、年龄、地区等），行为属性（设备操作习惯等）

设计：交互效果评估

研发：

- 人力资源 ROI 评估
- 智能推荐（千人千面）
- 场景化提示（私人助理）



#### how？

##### **代码埋点**

在页面的开发过程中，手动将埋点代码嵌入业务代码，然后在访问页面的过程中通过某种方式来触发埋点的上报

**优点：**

- 按需埋点，可定制化

**缺点：**

- 开发效率：需要人力定义，开发，验证，发版
- 埋点代码和业务代码存在耦合
- 流程繁琐：PM 提供需求，DS 设计，RD 开发自测，DS 验收

**适用场景：**

- 埋点诉求复杂，需要为业务定制化的行为埋点

  

##### **无埋点**

无埋点，也叫全埋点，它需要你接入客户端的sdk，接入之后，sdk会自动监听页面加载 / 点击 / 浏览等动作，在用户触发这些行为的时候，会上报预置定义好的事件。使用的时候根据具体页面路径和控件名称捞取数据，可以用来做 热力图 等

**优点：**

- 开发工作量小，人力成本低：只需要 sdk
- 数据链路完善：尽可能多的采集数据，对于之后可能用到的潜在埋点也有上报

**缺点：**

- 存在较多的无用上报，这些无用上报会导致一些性能损失和网络消耗；对于访问量非常大的业务来说，上报接收端将承受比较大的压力
- 存储成本增大
- 只能采集到用户肉眼可见的数据，不能灵活地自定义属性，行为记录信息少

**适用场景：**

- 业务多变，经常调整，且分析诉求较轻，不需要自定义事件的场景，如频繁上线或者更新的 h5 营销活动

  

##### **可视化埋点**

开发人员除集成采集 SDK 外，不需要额外去写埋点代码，而是由业务人员通过访问分析平台的「圈选功能」来“圈”出需要对用户行为进行捕捉的控件，并给出事件命名。圈选完毕后，这些配置（**一般通过埋点控件的** **xpath** **确定上报的位置**）会同步到各个用户的终端上，由采集 SDK 按照圈选的配置自动进行用户行为数据的采集和发送。

**优点：** 

- 开发周期短，人力成本低
- 与研发流程解耦，产运也可以使用
- 操作灵活，配置下发的方式发现问题修改及时

**缺点：**

- 在标记 view 上业内一般使用 xpath 的方式，这种方式对 dom 结构有较强的依赖。dom 结构发生变化可能导致 xpath 失效，从而导致埋点失效。
- 可覆盖范围有限，支持的埋点都是可视化埋点出发，并不能实现覆盖全部业务埋点
- 自定义困难

**适用场景**：

- 业务页面多，且变动相对不频繁，分析场景可列举
- 用户行为直接和页面可视元素挂钩



### 埋点模型

事件：用户行为和用户操作，比如页面打开 / 离开，模块曝光 / 点击，app 冷启动 / 隐藏后台/ 从后台打开/ 销毁

属性：

- 用户信息：用户 ID，名称等
- 时间信息：时间戳，时区
- 设备/网络/地域信息：ip，运营商。设备类型，操作系统类型/版本，设备id，国家，城市
- 应用信息：app version， app id，app name，环境，来源
- 时间具体信息



### 上报方式

真实场景：批量 + 延时，不能阻塞业务程序执行，需要用户无感知，流量来买单

##### 批量 / 单条

单条上报聚合，大大减少数量请求，比如列表曝光

##### 实时 / 延时

先本地化存储，上报延后，优先处理业务逻辑，程序空闲时上报



### 注意事项

**数据安全性：**

- 敏感数据加密，完善数据授权，对数据下载强监控

**埋点准确性**：

- 模块曝光：窗口可视区域内 &&  组件矩形与视窗有交集 && 交集垂线距离 >= 1px && 停留时间 >= xx ms
- pv 上报：触发时机需要早于该页面其他任何事件，pv上报里存在异步可能让执行变晚
- 重复曝光和刷新机制：同一个模块多次出现去重，模块刷新是否上报

**对业务逻辑的阻塞：**

- 埋点代码在业务逻辑代码后，包在单独的 try catch
- 批量 + 延时上报