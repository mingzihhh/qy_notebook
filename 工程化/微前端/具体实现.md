### 实现微前端的技术和方法

| **容器**      | **特点**                                                     |
| ------------- | ------------------------------------------------------------ |
| Iframe        | 简单、隔离性强、可靠性能较差、应用间很难共享状态、无法缓存路由 |
| Spa           | 自定义程度高复杂                                             |
| webcomponents | 较简单兼容性较差生态不完善                                   |

1. **Iframe**：

   - https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe
   - sandbox 属性：通过 `sandbox` 属性，开发者可以控制 `iframe` 中嵌入的内容的一些行为，以减少潜在的安全风险。
   - 使用 iframe 标签将各个子应用嵌入到主应用中。这种方式实现简单，但存在一些缺点，例如
     - 跨域问题：跨域策略非常严格，无法轻松地访问和操作不同域中的 `iframe` 内容
     - 性能问题：
       - 多次加载：如果多个 `iframe` 共享相同的资源（例如库、样式表等），这些资源需要在每个 `iframe` 中多次加载，导致资源浪费和加载时间增加。
       - 浏览器渲染：每个 `iframe` 都会被视作一个独立的文档，可能导致较高的内存消耗和更多的页面重绘/重排操作，对性能产生负面影响。

     - UI不同步：
       - 如果需要统一风格，必须在每个 `iframe` 中重复导入相同的样式文件
       - DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
     - 通信复杂：通常需要使用 `window.postMessage` 进行跨窗口通信
     - 共享状态困难：通常需要借助外部存储（例如 localStorage、cookies）或跨窗口通信来实现
     - url 同步问题：`iframe` 中的应用会有各自的路由和导航状态，但这些状态变更默认不会反映到主页面的 URL 上，用户刷新整个主页面时可能会丢失 `iframe` 内部应用的当前状态


   ```
   // 完全沙盒化，禁止所有行为
   <iframe src="https://example.com" sandbox></iframe>
   
   // 允许脚本运行,同源访问,表单提交、弹出窗口和下载，但是不允许其他行为
   <iframe src="https://example.com" sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-downloads"></iframe>
   ```

   

2. **JavaScript 加载器**：

   - 使用 JavaScript 动态加载各个子应用的代码，并将其插入到主应用中。这可以通过自定义的加载器、SystemJS 或 Webpack Module Federation 来实现。

3. **前端路由**：

   - 使用前端路由来管理各个子应用的加载和切换。例如，基于 URL 的路由，当用户导航到某个特定路径时，主应用会加载对应的子应用。

4. **Web Components**：

   - 使用 Web Components 技术（如 Custom Elements、Shadow DOM）来实现子应用的封装和隔离。每个子应用可以封装成一个独立的 Web Component，与其他子应用相互独立。



### 业界方案

|              | **iframe** | **single-spa** | **qiankun** | **garfish**      | **emp**     |
| ------------ | ---------- | -------------- | ----------- | ---------------- | ----------- |
| 沙箱         | 强         | 中             | 中          | 中               | 中          |
| 父子通信     | 弱         | 强             | 强          | 强               | 强          |
| 预加载       | 不支持     | 不支持         | 支持        | 支持             | 支持        |
| 资源加载形式 | html       | bundle         | html/bundle | html/bundle      | html/bundle |
| 依赖共享     | 不支持     | 不支持         | 不支持      | 支持（external） | 支持（MF）  |

需要面临的问题：

- 怎么注入加载入口脚本，从哪儿加载，怎么控制版本？
- 在哪儿上线，怎么上线？
- 子应用上线升级版本，怎么不让主应用重新打包？
- 如何选择不同版本 上线 / 回滚 / 灰度？
- 如何查看现在所有子应用的列表？
- 多个版本之间切换如何集成联调？
- ...

**我们对「微前端」的需求，不只是一个「微前端框架」，更是需要一整个配套的「微前端体系」**

- 治理体系：上线管理平台 + 上线发布流程

  - 应用管理：能上线各种主应用、子应用不同版本，列出上线应用不同版本的入口地址

  - 依赖管理：明确管理父子应用依赖关系，将子应用入口地址注入父应用，而不是 hardcode 写到父应用的代码中

  - 产物管理

  - 版本发布

  - 灰度方案

  - 私有化

  | **加载容器**                                                 | **管理平台**                                                 |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | [Qiankun](https://qiankun.umijs.org/) (基于 single-spa)      | OneX (阿里内部-蚂蚁金服)                                     |
  | MicroX (阿里内部)                                            | MicroX + CSKit (阿里内部-阿里云智能)                         |
  | [icestark](https://micro-frontends.ice.work/)                | Iceworks (阿里内部-飞冰)                                     |
  | [alfajs](https://alfajs.io/)                                 | Alfa (阿里内部-阿里云控制台)                                 |
  | [Garfish](https://gar.bytedance.net/docs/guide/introduction.html) | [Goofy web](https://cloud.bytedance.net/goofy/2/garfish-deploy/garfish-list?nohash=1) (字节内部) |
  | Kura (基于 system.js)                                        | RangesVersion + Maat (字节内部)                              |

- 运行时容器 【微前端框架】
  - 应用加载
    - 根据注册的子应用，通过给定的 url，加载约定格式的子应用入口，并挂载到给定位置
    - 入口格式：html / js 
    - 依赖关系确定：构建时 / 运行时
  - 生命周期：加载 / 挂载 / 更新 / 卸载等
    - 加载 / 挂载时做的初始化、权限守卫、 语言等
    - 卸载时做清理，如卸载 script 标签、style 标签、子应用 dom 等
    - 以及路由、父子通信时做双向更新的桥梁
  - 路由同步
    - 子应用的路由切换时，同步更新 url； url 跳转 / 更新时，同步更新子应用；也就是对子应用做到路由等同于 url
  - 应用通信
    - 支持父子应用之间便捷地相互通信，不像 postMessage 那样难用
    - 兄弟应用相互通信：大家都是用父应用作 EventHub
  - 隔离沙箱：为了各个应用「互补干扰」，需要把各个应用在“隔离”的环境中执行
    - 避免 全局样式冲突混乱，JS 全局变量被 污染 / 篡改 / 替换
  - 异常处理
    - 以上所有东西在报错时的统一处理，比如加载失败、或者路由匹配失败

- 开发配套
  - 文档
  - 脚手架
  - 联调
    - 本地开发子应用可脱离父应用 独立启动开发调试
    - 调试本地子应用和父应用接入，两者都用本地启动
    - 线上 bug 复现，需要调试子应用和父应用接入，其中一个本地启动，另一个加载线上
  - 构建
  - 发布
  - devTools