## JS异步

异步就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。

- 回调函数
- 事件监听
- 发布/订阅
- Promise 对象
- generator

---



#### 并发（concurrency）和并行（parallelism）区别

**并发与并行的区别？**

并发(Concurrency)是指程序的设计结构，**在同一时间内多件事情能被交替地处理**。重点是，在某个时间内只有一件事情在执行。比如：多个任务在同一个 CPU 核上按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。针对 CPU 内核来说，任务仍然是按细粒度的串行执行。

并行(Parallelism)是指程序的运行状态，在同一个时间内有几件事情并行在处理。由于一个线程在同一时间只能处理一件事情，所以**并行需要多个线程在同一时间执行多件事情**。多个任务真正的分配到不同的 CPU 内核上去执行的，它们是真正的同时执行。

JavaScript引擎是基于事件驱动**单线程执行**的，也就是同一时间只能运行一个线程，浏览器在运行时只开启了一个JS引擎线程来解析和执行JS。

在一个 js 线程上支持并发，不存在并行，也就是同一个时间只能执行一段 js 代码。

setTimeout() 只是延时执行，不是并行。



---



#### 回调函数

**什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？**

在 JavaScript 中，函数是对象。因此，函数可以将函数作为参数，并且可以由其他函数返回。执行此操作的函数称为**高阶函数**。**任何作为参数传递的函数都称为回调函数**。

但是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell），即多次连续回调

回调地狱的根本问题就是：

1. 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
2. 嵌套函数一多，就很难处理错误



---



#### Promise对象

将回调函数的嵌套改为链式调用，解决了回调地狱的问题。

Promise 的写法只是回调函数的改进，缺点：代码冗余，无法取消 `Promise`，错误需要通过回调函数捕获。

三种状态，分别是：

1. 等待中（pending）
2. 完成了 （resolved）
3. 拒绝了（rejected）

每次调用 `then` 之后返回的都是一个 `Promise`，并且是一个全新的 `Promise`，原因也是因为状态不可变。如果你在 `then` 中 使用了 `return`，那么 `return` 的值会被 `Promise.resolve()` 包装

---

#### Generator

`Generator` 最大的特点就是可以控制函数的执行。

**function** ***foo**(x) {
**let** y = 2 * (**yield** (x + 1))
**let** z = **yield** (y / 3)
**return** (x + y + z)
}
**let** it = foo(5)
console.log(it.next())   // => {value: 6, done: false}
console.log(it.next(12)) // => {value: 8, done: false}
console.log(it.next(13)) // => {value: 42, done: true}

---

#### asysc及await

#### 常用定时器函数