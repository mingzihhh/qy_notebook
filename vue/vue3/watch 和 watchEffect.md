`watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：

- `watch` 只追踪**明确侦听的数据源**。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。`watch` 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
  - 只能监听以下四种数据：
    - `ref`定义的数据。
    - `reactive`定义的数据。
    - 函数返回一个值（`getter`函数）
    - 一个包含上述内容的数组
  - reactive 与 ref 在监听对象的时候，主要有以下两点区别：
    - reactive 类型是不允许改变整个对象的，也就是说不能给它赋值一个新对象，因此它就不会出现监听整个对象发生变化的情况；Reactive 默认开启深度监听，直接可以监听到属性变化
    - ref 默认监听对象地址变化，或者使用 deep: true
- `watchEffect`，则会在副作用发生期间追踪依赖，**不用明确指出监听的数据**。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。
  - 如果在 if 条件里使用了或运算符||，它会按照条件顺序进行监听，一旦前面的条件符合，则后续的条件将不会监听
  - watchEffect是立即监听的，相当于watch配置了immediate为true一样
  - watchEffect无论是基本类型还是对象类型，它都可以监听到
  - watchEffect的解除监听方式跟watch是一样的



#### 解除监听

```
const stopWatch = watch(sum,(newValue,oldValue)=>{
  ......
})
console.log(stopWatch)
```

