### 页面加载性能

首次访问时，应用展示出内容与达到可交互状态的速度。这通常会用 Google 所定义的一系列 [Web 指标](https://web.dev/vitals/#core-web-vitals) (Web Vitals) 来进行衡量，如[最大内容绘制](https://web.dev/lcp/) (Largest Contentful Paint，缩写为 LCP) 和[首次输入延迟](https://web.dev/fid/) (First Input Delay，缩写为 FID)。



- 使用 SSR  / SSG 缓解首屏加载缓慢的问题：比如对于 SPA 的主应用，可以单独部署营销相关的页面。理想情况下，营销页面应该是包含尽可能少 JS 的静态 HTML，并用 SSG 方式部署。
- 压缩 JavaScript 打包产物的体积
  - 构建时：
    - tree-shaking：许多 Vue 的API 可以被 tree-shake
    - 使用了构建步骤时，模板会被预编译，因此我们无须在浏览器中载入 Vue 编译器。这在同样最小化加上 gzip 优化下会相对缩小 **14kb** 并避免运行时的编译开销。
  - 管理依赖项
    - 尽量选择提供 ES 模块格式的依赖，它们对 tree-shaking 更友好，比如 lodash-es 代替 lodash
    - 查看依赖的体积，并评估与其所提供的功能之间的性价比，尽可能避免引入过重的依赖
- 代码分割
  - 使用异步组件作为路由组件：使用懒加载暂时略过了那些不是立即需要的功能， Rollup (Vite 就是基于它之上开发的) 或者 webpack 这样的打包工具可以通过分析 ESM 动态导入的语法来自动进行代码分割



### 更新性能

应用响应用户输入更新的速度。比如当用户在搜索框中输入时结果列表的更新速度，或者用户在一个单页面应用 (SPA) 中点击链接跳转页面时的切换速度。



- 传给子组件的 props 尽量保持稳定，避免不必要的更新
- 使用 v-once：可以用来渲染依赖运行时数据但无需再更新的内容。它的整个子树都会在未来的更新中被跳过
- 使用 v-memo：可以用来有条件地跳过某些大型子树或者 `v-for` 列表的更新
- 计算属性尽量保持稳定：在 Vue 3.4 及更高版本中，计算属性仅在其计算值较前一个值发生更改时才会触发副作用，但是当返回值是对象则不起作用



### 大数据方案

#### 虚拟列表

- 只渲染可视区域附近的元素
- 在用户滚动时，根据可视区域更新渲染的内容，移除不在视口内的元素，减少 DOM 节点数量。

- 给滚动容器设置一个整体高度，以维持滚动条的正常显示。在列表滚动时使用空白占位的方式保持整体高度不变，这样可以让用户顺畅地滚动。

https://github.com/Akryum/vue-virtual-scroller



#### 减少大型不可变数据的响应性开销

Vue 的响应性系统默认是深度的，但是数据量巨大时，深度响应性会导致不小的性能负担，因为每个属性访问都将触发代理的依赖追踪。好在这种性能负担通常只有在处理超大型数组或层级很深的对象时，例如一次渲染需要访问 100,000+ 个属性时，才会变得比较明显。因此，它只会影响少数特定的场景。

**解决方案**：使用 [`shallowRef()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref) 和 [`shallowReactive()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) 来绕开深度响应，只在其顶层是响应式的，对所有深层的对象不会做任何处理

**使用场景**：一些复杂的图表场景，比如绘制地图等



#### 避免不必要的组件抽象

在合适的场景下（渲染次数较少）使用无渲染组件或高阶组件进行逻辑抽象或代码组织，因为组件实例比普通 DOM 节点要昂贵得多，而且为了逻辑抽象创建太多组件实例将会导致性能损失。

比如在大型列表中。想象一下一个有 100 项的列表，每项的组件都包含许多子组件。在这里去掉一个不必要的组件抽象，可能会减少数百个组件实例的无谓性能消耗。