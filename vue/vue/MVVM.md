## MVVM

MVVM是把MVC里的Controller和MVP里的Presenter改成了ViewModel

model + View + ViewModel

**View的变化会自动更新到ViewModel，ViewModel的变化也会自动同步到View上显示。**

这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应的操作。

MVVM 的设计思想：关注 Model 的变化，让 MVVM 框架去自动更新 DOM 的状态，从而把开发者从操作 DOM 的繁琐步骤中解脱出来 



**View**

作为视图模板存在。在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，**View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明**。

**ViewModel**

是业务逻辑层（一切JS可视业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在viewmodel里面负责监控两边的数据）

把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。**ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。**

MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的最重要一环。

**Vue 中主要通过数据劫持（Object.defineProperty() / Proxy）和发布订阅模式实现**

**model**

对应数据层的域模型，它主要做**域模型的同步**。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。



**优点**

- **关注点分离：** MVVM模式通过明确的分层将数据、用户界面和业务逻辑分离开来。这有助于提高代码的可维护性和可测试性，使开发人员可以更容易地修改、扩展和维护不同的部分。

- **代码重用：** ViewModel 可以根据不同的视图需求进行调整，从而实现业务逻辑的重用。这允许您在不同的视图之间共享相同的 ViewModel。

- **团队协作：** MVVM模式的分层结构可以使不同的团队成员（如设计师、前端开发者、后端开发者）在不同的层次上独立工作，减少了彼此的依赖性。

- **可维护性：** 由于数据逻辑和展示逻辑分开，所以对逻辑的修改和调试不会影响用户界面的呈现。

- **数据绑定：** MVVM模式通常具有双向数据绑定的功能，使数据与视图保持同步，从而实现了更实时的用户体验。

- **响应式编程：** MVVM模式通常涉及响应式编程范式，使数据的变化能够自动传播到相关的视图中

  


**缺点**

- **复杂性：** MVVM模式引入了额外的层次和概念，可能会增加项目的初始学习成本，特别是对于初学者来说。

- **性能：** 在某些情况下，MVVM模式可能引入额外的性能开销，特别是在实现数据绑定和观察者模式时。虽然现代前端框架通常会优化这些问题，但仍然需要小心考虑性能问题。
- **过度工程：** 在小型应用中，采用MVVM模式可能会导致过度设计，增加不必要的复杂性。
- **状态管理：** 在一些复杂的应用中，随着视图和数据逻辑的增加，可能会涉及到复杂的状态管理问题。如果不恰当地管理好状态，可能会导致应用变得难以理解和维护。





简单实现：

```
```

