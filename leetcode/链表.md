链表是一种物理存储单元上**非连续、非顺序**的存储结构，方便删除和插入，对查询不友好

- 出现了环，造成死循环
- 分不清边界，导致边界条件出错。
  - 因为头节点可能变化，可以用虚拟头节点简化复杂的分类讨论
  - 注意头节点判空
- 搞不懂递归怎么做



LeetCode 707、设计链表

- 需要有头节点和 size
- 插入时注意单独判断头插和尾插
- 注意通过 size 判断 index 边界条件



LeetCode 146、LRU 缓存机制

- 哈希表 + 双向链表：哈希表用来记录 key 对应的节点，双向链表方便插入删除操作，所有操作均为 O(1)
  - 为什么选择哈希表 + 双向循环链表
    - 哈希：**满足 *O*(1) 的快速查找**，但是哈希表是无序的，无法知道里面的键值对哪些最近访问过，哪些很久没访问。
    - 双向循环链表：**满足  *O*(1) 的删除和移动**
      - 数组元素的插入/移动/删除都是 *O*(*n*)，单向链表删除节点需要访问前驱节点，只能花 *O*(*n*) 从前遍历查找
  - 简化版可以使用 map，map 是有序的，可以按照插入顺序存储。
  
- 需要拆分出删除一个节点，插入头节点，获取节点（删除节点并在链表头插入）的基本操作



LeetCode 24、两两交换链表中的节点

- 遍历：添加一个 fakeHead，遍历从 mockHead 开始
- 递归：
  - 递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。



LeetCode 19、删除链表的倒数第 N 个结点

- 栈：遍历链表，并使用栈先进后出的特性
- 双指针：

  - 可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点
  - **让 second 指向  fakeHead**，当 first 遍历到链表的末尾时，second 指向删除节点的前驱节点





LeetCode 83、删除排序链表中的重复元素

- 由于给定的链表是排好序的，因此**重复的元素在链表中出现的位置是连续的**，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。



LeetCode 82、删除排序链表中的重复元素  II

- 和 83 类似，由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（dummy node）指向链表的头节点。
- 如果当前 *cur.next* 与 *cur.next.next* 对应的元素相同，那么我们就需要将 *cur.next* 以及所有后面拥有相同元素值的链表节点全部删除。



LeetCode 234、回文链表

- 复制链表值到数组列表中，使用双指针法判断是否为回文。



LeetCode 141、环形链表

- 哈希表：哈希表存遍历过的节点，每遍历一个节点，都查看哈希表是否存在当前节点，如果存在，则说明链表有环
- 双指针：快、慢指针，从头节点出发，慢指针每次走一步，快指针每次走两步，不断比较它们指向的节点的值。相对于slow来说，fast是一个节点一个节点的靠近slow的，如果节点值相同，说明有环。如果不同，继续循环



LeetCode 142、环形链表 II

- 哈希表：遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。
- 双指针：先判断环，判断环的逻辑和 141 相同；从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点





LeetCode 160、相交链表

- 简单方法：用哈希存下来一条链表的数据，再比较

- 双指针遍历：A + C + B = B + C + A，A 是链表 a 不同的地方，B 是链表 b 不同的地方，C 是相同的地方

  - 每步操作需要同时更新指针 pA 和 pB
  
  - 如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。
  
  - 如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。
  
  - 当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。
  
    
  

LeetCode 203、移除链表元素

- 遍历：添加一个 fakeHead，遍历从 mockHead 开始，否则当移除节点是头节点时需要单独处理

- 递归：
  - 递归的终止条件是 head 为空，此时直接返回 head。
  - 当 head 不为空时，递归地进行删除操作，然后判断 head 的节点值是否等于 val 并决定是否要删除 head。



LeetCode 21、合并两个有序链表

- 遍历：设置一个 preHead 作为哨兵节点，方便返回合并后的链表，通过 prev 指针完成遍历

- 递归：

  - 终止条件是如果两个链表有一个为空
  - 判断 `l1` 和 `l2` 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。



LeetCode 21、合并K个升序链表

- 分治合并，即对 K 条链表进行两两合并，按照一分为二再合并的逻辑，递归像是在后序遍历一棵平衡二叉树，两两合并的方法参考 21



LeetCode 328、奇偶链表

- 将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。
- 全部节点分离完毕的条件是 `even` 为空节点或者 `even.next` 为空节点，此时 `odd` 指向最后一个奇数节点（即奇数链表的最后一个节点）



LeetCode 328、反转链表 I

- 遍历：需要存储当前节点的前一个节点（修改 next）和后一个节点（继续遍历）

- 递归：
  - 终止条件是当前节点或者当前节点的 next 为空
  - 注意的是 *n*1 的下一个节点必须指向 null。如果忽略了这一点，链表中可能会产生环。



LeetCode 92 、反转链表 II

- 简单方法：把需要翻转的链表截出来，记录按照 I 中反转，再补到原来的链表中
- 头插法：
  - 对简单方法的优化：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次
  - 在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置
  - 用三个指针变量 `pre`、`curr`、`next` 来记录反转的过程中需要的变量
- 一次遍历：
  - 找到翻转区间的前一个节点，记做 p0
  - pre = null，按照 238 翻转 [left, right] 链表
  - 翻转结束时**，pre 指向应该翻转的最后一个结点，cur 指向翻转区间的后一个结点**
  - 调整链表连接关系：更改 p0 指向，p0.next.next (原来翻转区间第一个结点的 next)  = cur，p0.next = pre
  



LeetCode 25 、K 个一组翻转链表

- 计算链表长度，翻转之前先判断剩余结点个数，小于 k 个不翻转
- 翻转过程和 92 类似，每次翻转结束需要把 p0 更新成下一段要翻转的链表的上一个结点，就是 p0.next



LeetCode 2、两数相加

- 将两个链表中同一位置的数字可以直接相加，并与当前位置的进位值相加；如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。
- 注意末尾进位：如果链表遍历结束后，进位制不为0，还需要在答案链表的后面附加一个节点，节点的值为进位制



LeetCode 138、随机链表的复制

- 将复制分成两个步骤，先正常复制链表，使用 hashMap 记录 <originalNode, newNode>，再重新遍历，通过 hashMap.get(originalNode.random) 获取 random 对应的 newNode



LeetCode 148、排序列表

- 归并排序 + 递归

- 先找到中间结点的前一个结点，断开它和中间结点的连接，将链表分成把原链表均分成了两段更短的链表，**递归**地处理每个链表，最后按照顺序连接成一个完整链表

  - 递归结束的条件：如果链表为空或者只有一个节点，无需排序

- LeetCode 876 + LeetCode 21 + 递归

  



LeetCode 876、链表的中间结点

- 数组：对链表进行遍历，同时将遍历到的元素依次放入数组，通过下标取值
- 快慢指针：慢指针走一步，快指针走两步，快指针走完时慢指针在中间



LeetCode 143. 重排链表

- 快慢指针找到中点 ，拆成两个链表  + 反转后半部分的链表 +  merge 两个链表，后面的塞到前面的“缝隙里”



LeetCode 237. 删除链表中的结点

- 让当前节点的值变为下一个节点的值，删除下一个节点



LeetCode 61. 旋转链表

- 使用快慢指针，找到倒数第 k 个节点（新头结点）：slow 会停在「新头结点」的「前一位」，也就是「新尾结点」
- 处理边界情况：
  - 与链表长度成整数倍的旋转都是没有意义的，需要先计算链表长度 n ，k % n 是实际需要旋转的长度
  - k 是 0 或者链表为空



LeetCode 86. 分隔链表

- 按要求遍历原链表并分成large 和 small 两个链表，再拼接到一起
- 注意遍历结束时，需要将 large 的 next 指针置空，否则会有环
