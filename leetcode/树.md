#### 二叉树深度优先遍历

**前中后序遍历的区别是什么：在于处理当前节点的时间**

DFS 遍历中每个节点有 3 次不同的驻留阶段，在其中一个时间点拿当前节点做事，就分别对应前中后遍历

- 前序遍历在第一次访问节点时处理节点的内容
- 中序遍历在访问右节点之前处理节点的内容

- 后序遍历在最后一次访问时处理节点的内容



**前序遍历**

LeetCode  144. 二叉树的前序遍历

- 中左右

```
// 递归
function traversal(cur: TreeNode | null, res: number[]) {
    if (!cur) return;
    res.push(cur.val);
    traversal(cur.left, res);
    traversal(cur.right, res);
}

// 迭代
// 入栈 右 -> 左
// 出栈 中 -> 左 -> 右
function preorderTraversal(root, res = []) {
	if (!root) return res;
	const stack = [root];
	let cur = null;
	while(stack.length) {
		cur = stack.pop();
		res.push(cur.val);
		cur.right && stack.push(cur.right);
		cur.left && stack.push(cur.left);
	} 
	return res;
}
```



**后序遍历**

 LeetCode  145.二叉树的后序遍历

- 左右中

```
// 迭代，和前序类似
// 入栈 左 -> 右
// 出栈 中 -> 右 -> 左 结果翻转
function postorderTraversal(root, res = []) {
	if (!root) return res;
	const stack = [root];
	let cur = null;
	while(stack.length) {
		cur = stack.pop();
		res.push(cur.val);
		// 左右顺序变化
		cur.left && stack.push(cur.left); 
		cur.right && stack.push(cur.right);
	} 
	// 翻转
	return res.reverse();
}
```





**中序遍历**

LeetCode   94.二叉树的中序遍历

- 左中右

```
// 迭代，处理顺序和访问顺序不一致
// 入栈 左 -> 右
// 出栈 左 -> 中 -> 右
function inorderTraversal(root, res = []) {
	if (!root) return res;
	const stack = [];
	let cur = root;
	while (stack.length  || cur) {
		// 访问到最底层
		if (cur) {
			stack.push(cur);
			cur = cur.left; // 左
		} else {
			// 弹出：中
			cur = stack.pop();
			res.push(cur.val);
			cur = cur.right; // 右
		}
	}
	return res;
}
```



#### 二叉树广度优先遍历

**层序遍历**

LeetCode 102.二叉树的层序遍历

- 借用队列来实现，**队列先进先出，符合一层一层遍历的逻辑**

```
function levelOrder(root) {
    const res = [], queue = [root];
    if (!root) return res;
    while(queue.length) {
    	  // 记录上一层级节点数
        const len = queue.length;
        //存放每一层的节点 
        const curLevel = [];
        for (let i = 0; i < len; i++) {
            const node = queue.shift();
            curLevel.push(node.val);
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        res.push(curLevel);
    }
    return res;
};
```



LeetCode 103.二叉树的锯齿形层序遍历

- 主要思路和层序遍历相同，偶数层翻转 curLevel 加入 res



LeetCode 104. 二叉树的最大深度

- 最大的深度就是二叉树的层数
- 递归：1 + Math.max(maxDepth(root.left), maxDepth(root.right));



LeetCode 111. 二叉树的最小深度

- 递归，深度是根节点到叶子节点的长度，所以要注意分别处理根节点有没有左右子节点的情况





LeetCode 105. 从前序与中序遍历构造二叉树

- 根据前序和中序的关系，前序可以得到根节点，在中序中定位到根节点，可以划分出左右子树，然后 **递归** 构建左右子树



LeetCode 106. 从中序与后序遍历构造二叉树

- 后序数组的最后一个元素是根节点，在中序中定位到根节点，可以划分出左右子树
- **中序数组大小一定是和后序数组的大小相同的**，后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。




LeetCode 129. 求根节点到叶节点数字之和

- 递归分支维护一个 cur 变量，在下探的过程中计算，更新 cur
- 当遍历到叶子节点时，当前分支计算结束，返回 cur；否则递归计算左右分支

、

LeetCode 199. 二叉树的右视图

- **层序遍历**，取当前层的最后一个结点



LeetCode 226. 翻转二叉树

- 只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果
- 可以采用**前序递归**遍历，先进行交换左右孩子节点，然后反转左子树，反转右子树
- 后序也可以，但是中序不方便，因为中序遍历会把某些节点的左右孩子翻转了两次



LeetCode 236. 二叉树的最近公共祖先

- 从下往上处理，**后序遍历**

- 如果递归遍历遇到q，就将q返回，遇到p，就将p返回，那么如果左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。

  

LeetCode 100. 相同的树

- 先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。

  

LeetCode 101. 对称二叉树

- 如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

  - 它们的两个根结点具有相同的值

  - 每个树的右子树都与另一个树的左子树相同

- 上一题的变种



LeetCode 257. 二叉树的所有路径

- 递归暗含回溯，遍历完左子树，构建出合格的路径，加入解集，遍历右子树之前，路径要撤销最末尾的选择
  - 如果path用的是数组，需要弹出最后一项
  - 使用字符串，pathStr保存了当前节点的路径，递归右子树时，传入它即可，它不包含在递归左子树所拼接的东西
  - 因为每次 pathStr += root.val 是会生成新的字符串，但是数组是动态结构，会互相影响



LeetCode 543. 二叉树的直径

- 二叉树中从一个结点到另一个节点最长的路径，叫做二叉树的直径

- 简单 dfs

  - 单次执行流程中，先递归处理当前节点的左右节点，得到左右子树为根时的“往下”最大路径 l 和 r，两者中的较大值 +1 即是本次执行流程的返回值（+1 的含义是在子路径基础上增加当前节点）。
  - 同时，l + r 则是以当前节点为路径最高点时的路径长度，用此更新全局 ans 即可。



LeetCode 114. 二叉树展开为链表

- 先前序遍历，存下遍历结构，再更新每个节点的左右子节点的信息，将二叉树展开为单链表



LeetCode 222. 完全二叉树的节点个数

- 最简单的方式：递归计算
- 优化递归：利用完全二叉树的性质
  - 它的所有子树都是完全二叉树
  - 有的子树是满二叉树，满二叉树的节点个数是 2^h - 1
  - 对于每个节点 root，都判断一下它是否是满二叉树——左侧的高度 == 右侧的高，是的话通过公式计算，减少递归次数，否则正常递归



LeetCode 437. 左叶子之和

- 需要用 isLeft 参数判断当前子树是否为左子树
- 当遍历的是叶子节点，根据isLeft判断，是左叶子节点就返回 root.val
- 当遍历到别的节点，递归它们的左、右子树，isLeft 分别传 true 和 false



LeetCode 513. 找树左下角的值

- 层序遍历
- 递归：利用**前序遍历**，保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。



LeetCode 112. 路径总和 

- 使用深度优先遍历的方式递归遍历，终止条件：遍历到了叶子结点，暗含回溯



LeetCode 113. 路径总和 2

- 思路和 112 类似，不同点在于需要记录路径
- 为了维护经过的路径，在进入递归的时候要在 path 列表添加节点，结束递归的时候删除节点，跟回溯算法差不多类似的套路



LeetCode 437. 路径总和 3

- 两节点间的路径和 = 两节点的前缀和之差，遍历整颗树一次，记录每个节点的前缀和，并查询该节点的祖先节点中符合条件的个数，将这个数量加到最终结果上。
- 使用哈希表存储前缀和以及对应的节点数量
- 需要注意的问题
  - 预设 hashMap[0] = 1，为了方便计算前缀和，**把任意路径和都表示成两个前缀和的差**
  - 恢复状态：因为要求路径向下，一个节点必须是另一个节点的祖先节点，也就是说当我们把一个节点的前缀和信息更新到map里时，它应当只对其子节点们有效，否则会重复计算。所以需要在遍历完一个节点的所有子节点后，将其从map中除去，



LeetCode 617. 合并二叉树

- 深度优先搜索，从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。
- 需要考虑都为空 / 都不为空 / 一个为空 三种情况



LeetCode 124. 二叉树中的最大路径和

- 路径和长度=左子树最大路径和+右子树最大路径和+结点值

- dfs：递归求出左右子树最大路径，再递归求出最大的路径和；dfs 返回的值如果是负数则取 0，负数只会让和变小



#### 二叉搜索树

**中序遍历下，输出的二叉搜索树节点的数值是有序序列**



LeetCode 108. 将有序数组转换为二叉搜索树

- BST 的中序遍历是升序的，因此本题等同于根据**中序遍历**的序列恢复二叉搜索树
- 升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树
- 要求高度平衡，所以需要选择升序序列的中间元素作为根节点
  - **平衡二叉树** 是指该树所有节点的左右子树的高度相差不超过 1。



LeetCode 98. 验证二叉搜索树

- 使用数组，可以递归中序遍历将二叉搜索树转变成一个数组，再比较数组是否有序
- 二叉搜索树的性质就是左子树中所有节点的值都小于(这里是<而非<=)根节点，右子树中所有节点的值都大于(同理这里是>而非>=)根节点
  - 直接递归，验证左子树的时候，将左子树值的最小范围和最大范围作为参数传入，同理右子树也是如此



LeetCode 230. 二叉搜索树中第 k 小的元素

- **中序遍历**就是在从小到大遍历节点值，所以遍历到的第 *k* 个节点值就是答案。
- LeetCode 108 的变种



LeetCode 1382. 将二叉搜索树中变平衡

- 先中序遍历二叉搜索树，存在数组中，再将有序数组转化为平衡二叉搜索树



LeetCode 530. 二叉搜索树的最小绝对差

- 中序遍历二叉搜索树，计算中序遍历中的相邻两数的差值，取最小值
