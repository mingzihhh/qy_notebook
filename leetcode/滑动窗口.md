LeetCode 3、无重复字符的最长子串

- 使用一个数组或者下标来维护滑动窗口：O(n2)，O(n)

- 使用 map 来存储当前已经遍历过的字符，key 为字符，value 为下标

  - 使用 i 来标记无重复子串开始下标，j 为当前遍历字符下标
  - 遍历字符串，判断当前字符是否已经在 map 中存在，存在则更新无重复子串开始下标 i 为相同字符的下一位置，此时从 i 到 j 为最新的无重复子串，更新 max ，将当前字符与下标放入 map 中
  - O(n)，O(n)



LeetCode 209、长度最小的子数组

- 连续子数组可以表示为 [i,j]：从第 i 项到第 j 项。
- 当 [i,j] 子数组和 >= s，如果此时扩张窗口，条件就依然满足，但背离“最小长度”的要求。所以选择收缩窗口：i 右移，直到条件不再满足（是一个循环），这是在优化可行解，并让窗口长度挑战最小纪录。
- 当窗口的和 < s，此时应该扩张窗口，j 右移，直到条件重新满足。



LeetCode 76、最小覆盖子串

- 用一个 hash 统计 t 中字母出现情况；用 missingType 表示当前缺失的字符种类数（还要找齐几种字符），当它为 0 时，表示没有缺少任何种类，找齐了所有目标字符
- 使用滑动窗口，移动 r 遍历 s 串，根据 r 指向的新字符改变 hash 和 missingType 的情况
  - 当 missingType === 0，代表条件满足，移动 l 缩小窗口大小，并根据 l 指向的新字符改变 hash 和 missingType 的情况，直到不满足条件为止
  - 移动过程中记录最小窗口大小和此时 l 的位置即窗口起点



LeetCode 713、乘积小于 k 的子数组

- 边界条件：k <= 1时不可能满足，直接返回 0

- 与 209 类似，找到满足要求的数组范围
- **重点**：当滑动窗口的内层循环结束时，右端点固定在 right，左端点在 left,left+1,…,right 的所有子数组都是合法的，即满足要求的子数组有 right−left+1 个



LeetCode 239、滑动窗口最大值

- 单调队列：队列递减，队列头就是窗口最大值
- 根据新元素优化队列尾端，小于新元素的出队；判断队头元素位置是否在窗口内，超过时出队；记录对头作为答案




LeetCode 483、找到字符串中所有字母异位词

- 定长窗口：
  - 统计 p 的每种字母的出现次数：如果 *s*′ 的每种字母的出现次数和 *p* 的每种字母的出现次数都相同，那么 *s*′ 是 *p* 的异位词。
  - for 循环移动 right，并记录 right 字母出现次数，根据 *s*′ 长度计算 left 
    - 如果窗口长度不足 continue
    - 比较  *s*′ 和 *p* ，次数相同记录 left
    - left 离开窗口
  





