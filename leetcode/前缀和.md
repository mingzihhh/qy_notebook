### 前缀和

前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。

**适合解决涉及计算区间和的问题**，可以优化大数据查询性能

``` 
s[0] = 0;
s[1] = a[0];
s[2] = a[0] + a[1];
...
s[n] = a[0] + a[1] + ... + a[n-1];

=> s[n+1] = s[n] + a[n];
=> [2,5] 区间和 = s[6] - s[2]
```

s 数组是我们之前就计算好的累加和，所以后面每次求区间和的之后 我们只需要 O(1) 的操作。



 问：为什么要定义 s[0]=0，这样做有什么好处？

答：如果 left=0，要计算的子数组是一个前缀（从 a[0] 到 a[right]），我们要用 s[right+1] 减去 s[0]。如果不定义 s[0]=0，就必须特判 left=0 的情况了（读者可以试试）。通过定义 s[0]=0，任意子数组（包括前缀）都可以表示为两个前缀和的差。此外，如果 a 是空数组，定义 s[0]=0 的写法是可以兼容这种情况的。



LeetCode 303、区域和检索-数组不可变

- 先计算 nums 数组和，再根据前缀和知识得到区间和

  

LeetCode 1588、所有奇数长度子数组的和

- 先计算 nums 数组和，再根据前缀和知识得到区间和
- 遍历奇数长度区间



LeetCode 724、寻找数组的中心下标

- 先计算 nums 数组和，再根据前缀和知识得到区间和
- left = sums[i] - sums[0], right = sums[n] - sums[i+1]，比较 left 和 right



LeetCode 560、和为 K 的子数组

- 下标从 *i* 到 *j*−1 的非空连续子数组的元素和等于 *k*，即 s*[*j*]−*s*[*i*]=*k*(*i*<*j*)，计算 *s*[*i*] 的个数，等价于计算 *s*[*j*]−*k* 的个数。
- 在遍历 s[j] 的同时，用一个哈希表 cnt 统计 s[j] 的个数。那么枚举到 s[j] 时，从哈希表中就可以找到有 cnt[s[j]−k]] 个 s[i]，即为元素和等于 k 的子数组个数




- LeetCode 36、有效的数独

  