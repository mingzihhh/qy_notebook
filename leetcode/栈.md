- 使用堆栈可以很方便的保存和取用信息，因此长被用作算法和程序中的辅助存储结构，临时保存信息，供后面操作中使用。
  - 例如：操作系统中的函数调用栈，浏览器中的前进、后退功能。
- 堆栈的后进先出规则，可以保证特定的存取顺序。
  - 例如：翻转一组元素的顺序、铁路列车车辆调度。



LeetCode 20、有效的括号

- 为了快速判断括号的类型，我们可以使用 map 存储每一种括号。键为右括号，值为相同类型的左括号。
- 遇到左括号入栈，遇到右括号与栈顶元素匹配，可以匹配则出栈，否则失败；最后栈不为空也失败

​	

LeetCode 155、最小栈

- 在每个元素 `a` 入栈时把当前栈的最小值 `m` 存储起来。在这之后无论何时，如果栈顶元素是 `a`，我们就可以直接返回存储的最小值 `m`。
- 使用一个**辅助栈**，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。



LeetCode 150、逆波兰表达式求值

- 遇到操作数入栈；遇到运算符，左右操作数出栈，结果入栈

- 注意除法的处理：向零取整即正数向下（Math.floor），负数向上 （Math.ceil），或者直接去掉小数点后部分（Math.trunc）



LeetCode 32、最长有效括号

- 用栈模拟一遍，先将所有括号位置置 0，将所有无法匹配的括号的位置全部置1，例如: "()(()"的mark为[0, 0, 1, 0, 0]，再例如: ")()((())"的mark为[1, 0, 0, 1, 0, 0, 0, 0]

- 经过这样的处理后, 此题就变成了寻找最长的连续的0的长度

  

LeetCode 394、字符串解码

- 双栈法：一个栈记录数字作为倍数，一个栈记录字符串，遇到 [ 入栈，遇到 ] 出栈
- 使用正则：/(\d+)\[(\w+)\]/g 多次匹配，使用 s.replace(regex, fn) 处理，直到匹配不上为止



#### 单调栈

一种特殊的栈。在栈的「先进后出」规则基础上，要求「从 **栈顶** 到 **栈底** 的元素是单调递增（或者单调递减）」。其中满足从栈顶到栈底的元素是单调递增的栈，叫做「单调递增栈」。满足从栈顶到栈底的元素是单调递减的栈，叫做「单调递减栈」。



单调栈可以在时间复杂度为 O(n) 的情况下，求解出某个元素左边或者右边第一个比它大或者小的元素。

所以单调栈一般用于解决一下几种问题：

- 寻找左侧第一个比当前元素大的元素。
- 寻找左侧第一个比当前元素小的元素。
- 寻找右侧第一个比当前元素大的元素。
- 寻找右侧第一个比当前元素小的元素。



LeetCode 1475、商品折扣后的最终价格

- 维护一个存储下标的单调栈，从栈底到栈顶的元素对应价格是单调递增的



LeetCode 739、每日温度

- 本质：找到一个元素右边第一个比自己大的元素

- 维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。
- 由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。



LeetCode 84、柱状图中的最大矩形

- 本质：找到一个元素右边第一个比自己比的元素

- 对于一个高度，如果能得到向左和向右的边界，那么就能对每个高度求一次面积，遍历所有高度，即可得出最大面积
- 使用单调递增栈，在出栈操作时得到前后边界并计算面积：栈顶 bar 出栈时，此时要入栈的元素为右边小于栈顶 bar 的第一个 bar，出栈后的新栈顶 bar 为左边小于栈顶 bar 的第一个 bar
- 边界情况：[0, ...heights, 0]，引入高为 0 的虚拟 bar，不影响结果，解决栈顶出栈后栈为空或者最后一个 bar 无法出栈导致无法计算面积的情况