https://algo.itcharge.cn/01.Array/04.Array-Two-Pointers/01.Array-Two-Pointers/#_5-%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93

双指针分为「对撞指针」、「快慢指针」、「分离双指针」。

- **对撞指针**：两个指针方向相反。适合解决查找有序数组中满足某些约束条件的一组元素问题、字符串反转问题。
- **快慢指针**：两个指针方向相同。适合解决数组中的移动、删除元素问题，或者链表中的判断是否有环、长度问题。
- **分离双指针**：两个指针分别属于不同的数组 / 链表。适合解决有序数组合并，求交集、并集问题。



### **对撞指针**

LeetCode 15、三数之和

- 排序，升序排列

- 基本思路：a = nums[i]，b = nums[left]， c = nums[right]
  - 如果nums[i] + nums[left] + nums[right] > 0 就说明此时三数之和大了，需要 right 下标左移
  - 如果nums[i] + nums[left] + nums[right] > 0 就说明此时三数之和小了，需要 left 下标右移
  - 直到 left 和 right 相遇为止

- 去重（否则超时）：

  - nums[i] > 0 时直接返回 res
  - 判断 nums[i] 与 nums[i-1] 是否相同，相同时跳过
    - 如果判断 nums[i] 与 nums[i + 1]的话，会漏掉 {-1, -1 ,2}  这种数据
  -  在找到一个三元组之后，nums[left] 重复移，nums[right] 重复时右移



LeetCode 16、最接近的三数之和

- 和 15 类似，先排序再使用双指针，比较记录 diff 值

- 优化：
  - 判断 nums[i] 与 nums[i-1] 是否相同，相同时跳过
  
    

LeetCode 18、四数之和

- 和 15 类似，先排序再使用双指针，需要枚举前两个数，剩下两个数用双指针找
- 在用双层 for 循环枚举前两个数时，需要进行一些优化

```
   // b 类似
   if (a > 0 && x === nums[a - 1]) continue; // 跳过重复数字
   if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break; // 优化一
   if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue; // 优化二
```



LeetCode 12、盛最多水的容器

- 双指针，左右指针分别指向数组的左右两端，移动 **高度数字较小的那个指针**，直到两个指针相遇
  - 无论长板或短板向中间收窄一格，都会导致水槽 **底边宽度** −1 变短
  - 移动较小的那个可能会让高度变大，面积可能变大




LeetCode 42、接雨水

- 双指针：按列方向计算雨水，当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。
  - 先从左向右遍历，用一个数组记录每一个位置的左边最高高度；再从右向左遍历，用一个数组记录每一个位置的右边最高高度
- 单调栈：按行方向计算雨水




### 快慢指针

**一般需要保持数组顺序**

LeetCode 26. 删除有序数组中的重复项

- 慢指针指向将要赋值的位置，快指针指向待处理元素
- 快指针遍历完时，代表数组都被处理完，慢指针后面的元素都是重复元素



LeetCode 80. 删除有序数组中的重复项 II

- 因为数组是有序的，相同元素必然连续
- 简单方法：遍历一次，相同的时候 splice
- 双指针：慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即 
  - nums[fast] 表示待检查的第一个元素，nums[slow - 1] 为上一个应该被保留的元素所移动到的指定位置
  - nums[fast] !== nums[slow - 2]时，fast 位置的元素可以保留，移动到 slow 指向的位置；最后 slow 就是处理好的数组长度
  - 边界情况：长度不超过 2 的数组，无需进行任何处理



LeetCode 283、移动零

- 慢指针指向将要赋值的位置，快指针指向待处理元素

- 快指针遍历完时，代表数组都被处理完，慢指针后面的元素都是 0

  

LeetCode 27. 移除元素 

- 慢指针指向将要赋值的位置，快指针指向待处理元素

- 优化：可使用对撞元素，可以避免移动不需要移动的元素
  - 例如序列 [1,2,3,4,5]，当 *val* 为 1 时，我们需要把每一个元素都左移一位，实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。



LeetCode 392. 判断子序列

- 两个指针分别扫描长串和短串，如果指向的字符相同，两个指针都移动考察下一个字符；如果不相同，短串的指针不动，长串的指针移动考察下一个字符



### 分离双指针



