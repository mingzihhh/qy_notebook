**动态规划的核心思想**：

1. 把「原问题」分解为「若干个重叠的子问题」，每个子问题的求解过程都构成一个 **「阶段」**。在完成一个阶段的计算之后，动态规划方法才会执行下一个阶段的计算。
2. 在求解子问题的过程中，按照「自顶向下的记忆化搜索方法」或者「自底向上的递推方法」求解出「子问题的解」，把结果存储在表格中，当需要再次求解此子问题时，直接从表格中查询该子问题的解，从而避免了大量的重复计算。

https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485269&idx=1&sn=571a6366b0b592f103971ae3e119998b&scene=21#wechat_redirect

https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=1&sn=f1db6dee2c8e70c42240aead9fd224e6&chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&scene=21#wechat_redirect

**如何找到动态规划的状态转移关系**：

**1、**明确 `dp` 数组所存数据的含义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

**2、**根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。注意要确定好 bad case



LeetCode 118、杨辉三角

- 每一排的第一个数和最后一个数都是 1，即` c[i][0]=c[i][i]=1`。
- 其余数字，等于左上方的数，加上正上方的数，即 `c[i][j]=c[i−1][j−1]+c[i−1][j]`。



LeetCode 746、使用最小花费爬楼梯

- dp[i]：达到下标 i 的最小花费
- dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
- i 需要计算到 len





LeetCode 24、最长递增子序列

- dp[i]： 以 nums[i] 这个数结尾的最长递增子序列的长度。
- 初始化：`dp[i]` 初始值为 1，因为以 `nums[i]` 结尾的最长递增子序列起码要包含它自己

- dp[i] = Math.max(dp[i], dp[j] + 1)，nums[j] < nums[i]
- res = Math.max(...dp)



LeetCode 53、最大子数组和

- dp[i]： 以 nums[i] 这个数结尾的最大子数组和
- dp[i] = Math.max(dp[i - 1], 0) + nums[i]
- 如果之前的子数组元素和是负的，就不用拼在一起了



LeetCode 62、不同路径

- `dp[i][j]`：表示从（0 ，0）出发，到(i, j) 有`dp[i][j]`条不同的路径
- `dp[i][j] = dp[i - 1][j] + dp[i][j - 1];`
- 初始化：`dp[i][0] = 1; dp[0][j] = 1;  `



LeetCode 62、最小路径和

- 和 62 类似，注意求和处理
- 不想使用额外空间记录 dp 的话，就直接使用 grid



LeetCode 62、不同路径 2

- 和 62 类似，多了对障碍的处理
- “障碍”怎么处理：
  - 障碍点是无法抵达的点，是到达方式数为 0 的点；是无法从它这里走到别的点的点，即无法提供给别的点方式数的点
  - 如果 [i, j] 障碍，说明 `dp[i][j] = 0`；如果第一行 / 列有障碍，则它和它后面的点都到达不了



LeetCode 139、单词拆分

- dp[i]：长度为 i 的 s[0 : i-1] 的字符串是否能拆分成单词
- 用 j 去划分 s[0 : i], dp[i+1] 的值取决于 dp[j]  && s[j : i]是单词

- Bad case: dp[0] = true，只有 dp[0] 为真，dp[i+1] 才能只取决于 s[0:i] 是否为单词



LeetCode 198. 打家劫舍

- dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]
- dp[i] = Math.max(dp[i - 2] + nums[i],  dp[i-1])
  - 偷第 i 个房间：dp[i - 2] + nums[i]
  - 不偷第 i 个房间：dp[i-1]
- 初始化：dp[0] = nums[0], dp[1] = Math.max(nums[0], nums[1])



LeetCode 300. 最长递增子序列

- dp[i]: i之前包括i的以nums[i]结尾的最长递增子序列的长度
- 两层 for 循环，**j 是遍历 0 到 i-1**：`if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);`
- 初始化：dp[i] = 1



LeetCode 674.  最长连续递增子序列

- 和 300 类似，但是连续递增的子序列只跟前一个状态有关，只需要比较 i 和 i-1
- 单层 for 循环：`if (nums[i] > nums[i-1]) dp[i] = dp[i-1] + 1;`



LeetCode 718. 最长重复子数组

- 用二维数组可以记录两个字符串的所有比较情况

- `dp[i][j]`: 长度为`i`，末尾项为`A[i-1]`的子数组，与长度为`j`，末尾项为`B[j-1]`的子数组，二者的最大公共后缀子数组长度。
- 如果 `A[i-1] != B[j-1]`， 有` dp[i][j] = 0`
  如果 `A[i-1] === B[j-1] `， 有` dp[i][j] = dp[i-1][j-1] + 1`
- 初始化 `dp[i][j]=0`，`dp[i][0]` 和`dp[0][j]`其实都是没有意义的



LeetCode 1143. 最长公共子序列

- 和 718 的区别在于不要求连续
- `dp[i][j]`: 长度为`i`，末尾项为`A[i-1]`的子数组，与长度为`j`，末尾项为`B[j-1]`的子数组，二者的最大公共子序列长度。
- 如果 `A[i-1] != B[j-1]`， **有` dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); `**
  如果 `A[i-1] === B[j-1] `， 有` dp[i][j] = dp[i-1][j-1] + 1`
- 初始化 `dp[i][j]=0`



LeetCode 1035. 不相交的线

- 如果想要不相交，则必然相对位置要一致，换句话说就是：公共子序列，思路和 1143 相同



LeetCode 152、乘积最大子数组

- 需要考虑到负负得正的情况，所以需要记录 0 到 i 项范围内子数组的**最小乘积和最大乘积**
- 以最小乘积为例，对于以 nums[i] 为末尾的子数组能产生的最小积，它有 3 种情况：
  - 不和别人乘，就 nums[i] 自己
  - nums[i] 是负数，希望乘上前面的最大积
  - nums[i] 是正数，希望乘上前面的最小积
- 用两个变量分别去存每个位置算出的最小积和最大积，在迭代中更新即可

```
prevMin=min(prevMin∗nums[i],prevMax∗nums[i],nums[i])
prevMax=max(prevMin∗nums[i],prevMax∗nums[i],nums[i])
```

- 初始化：prevMin = nums[0], prevMax = nums[0]



LeetCode 647、回文子串

- `dp[i][j]`：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串
  - 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
  - 情况二：下标i 与 j相差为1，且s[i]与s[j]相同，例如aa，也是回文子串
  - 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看`dp[i + 1][j - 1]`是否为true。



LeetCode 5、最长回文子串

- 动态规划：`dp[i][j]`：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，类似 647，记录比较长度
- 中心扩散法：从每一个位置出发，向两边扩散即可，遇到不是回文的时候结束，需要分别考虑
  - 以s[i] 为中心的最长回文子串，奇数长度
  - 以s[i] ，s[i+1] 为中心的最长回文子串，偶数长度



LeetCode 516、最长回文子序列

- `dp[i][j]`：字符串s在[i, j]范围内最长的回文子序列的长度
- 在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。
  - 如果相同，`dp[i][j] = dp[i + 1][j - 1] + 2`
  - 如果不同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列，`dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])`
- 初始化 `dp[i][j]=1`
- 注意 i 是依赖 i+1 的，所以 i 要从下往上遍历，j 从上往下



### 背包问题

**常见变形**：

1. 至多装 x，求方案数/最大价值和
2. 恰好装 x，求方案数/最大/最小价值和
3. 至少装 x，求方案数/最小价值和

`dfs(i, x) = dfs(i-1, x) + dfs(i-1, x-w[i])`





LeetCode 416、分割等和子集

https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E6%80%9D%E8%B7%AF

-  背包的体积为sum / 2，背包如果正好装满，说明找到了总和为 sum / 2 的子集，背包中每一个元素是不可重复放入
-  dp[j] ： 容量为 j 的背包，所背的物品价值最大可以为dp[j]
-  `dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`，如果使用一维dp数组，**物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历 <= 保证元素不重复放入**
-  初始化：`dp[0] = 0`，因为dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。



LeetCode 1049、最后一块石头的重量 II

- 和 416 类似：将所有石头划分为两个子集，使得差值最小
  - dp[target]里是容量为target的背包所能背的最大重量，另一个子集就是sum - dp[target]

  - **在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的**

  - 相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]



LeetCode 322. 零钱兑换

- dp[j]: 凑足总额为 j 所需钱币的最少个数为 dp[j] 
- `dp[j] = min(dp[j - coins[i]] + 1, dp[j])`
- 初始化: dp[0] = 0，且初始化时下标非0的元素都是应该是 Infinity，方便在 min 比较时覆盖
- 两层 for 循环：一层循环物品，一层循环背包，这题两种顺序都可以
  - **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
  - **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。




LeetCode 279. 完全平方数

- 和 322 类似，完全背包问题
- dp[j]：和为 j 的完全平方数的最少数量为 dp[j]

- `dp[j] = Math.min(dp[j], dp[j - i*i] + 1)` 



LeetCode 494. 目标和

- 方法一：回溯，遍历所有表达式

- 方法二：dp

  - 假设加法的总和为x，那么减法对应的总和就是sum - x，所以我们要求的是 x - (sum - x) = target，x = (target + sum) / 2

  - **问题就转化为，用 nums 装满容量为 x 的背包，有几种方法**。

  - dp[j]，表示：填满 j（包括 j ）这么大容积的包，有 dp[j] 种方法
  - dp[j] = dp[j] + dp[j - nums[i]]，遍历物品放在外循环，遍历背包在内循环，且内循环倒序（为了保证物品只使用一次）。



LeetCode 120. 三角形最小路径和

- `dp[i][j] `表示到达第i层第j个元素的最小路径
- **自底向上递推**，`dp[i][j] = Math.min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j`
- bad case：最底层
