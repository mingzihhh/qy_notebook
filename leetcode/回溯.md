回溯法也可以叫做回溯搜索法，它是一种搜索的方式。

**回溯法并不是什么高效的算法**，**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

- 回溯函数模板返回值以及参数：返回值一般为void，参数需要结合逻辑
- 回溯终止条件：搜到叶子节点 <= 回溯全是树形结构
- 遍历过程：回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度
- **如何去重**：**需要数组排序， 用 used 数组 记录同一树枝上的元素是否使用过**
  - 如果要对树层中前一位去重，用 nums[i] === nums[i-1] && used[i-1] === false，说明同一树层上有两个重复元素，nums[i-1] 使用过
  - 如果要对树枝前一位去重，用 nums[i] === nums[i-1] && used[i-1] === true，说明同一树枝上有两个重复元素，nums[i-1] 使用过


```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)



### 回溯法解决的问题

#### 组合问题

N个数里面按一定规则找出k个数的集合



LeetCode 77、组合

- 经典的回溯剪枝：在每次递归中控制枚举的范围，下一个选择的遍历起点，是当前选择的数字 +1

- 当选够 k 个数时，就把它加入解集。但不是找到一个组合就完事，要找齐；所以，遇到完整解时，结束当前搜索分支，要撤销最后一个选择，回到选择前的状态，尝试另一个选择，去搜下一个分支
  
  

LeetCode 39、组合总和

- 描述节点的状态有：当前选择的起点，当前选择的数字，和当前数字和。

- 剪枝

  - 求和 >= target，不能选下去了，返回
  - 不产生重复组合：限制下一次选择的起点是基于本次的选择，这样下一次就不会选到本次选择同层左边的数



LeetCode 40、组合总和 II

- 和 39 的区别，每个数字在每个组合中只能使用一次，不同组合不能相同，所以**需要在同一树层去重**
- 用 used 数组 记录同一树枝上的元素是否使用过，同一树层 used[i - 1] == false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的，需要跳过
- 剪枝：
  - 递归单层遍历的时候判断 当前元素值大于目标值-总和的值 ，后面的元素不可能满足要求，直接终止本层递归



LeetCode 17、电话号码的字母组合

- 描述节点的状态有：当前选择的组合和用来遍历digits的 index，也就是记录遍历第几个数字了

- 取index指向的数字，并找到对应的字符集（手机键盘的字符集），然后for循环来处理这个字符集

  

LeetCode 22、括号生成

- 描述节点的状态有：当前构建的字符串，和左右括号所剩的数量。

- 剪枝：
  - 有左括号的时候可以随便选左括号
  
  - 右括号剩的比较多时才能选右括号，否则没办法成双成对
  



LeetCode 131、分割字符串

- 本题这涉及到两个关键问题：

  - 切割问题，有不同的切割方式：**切割问题类似组合问题**，传入 startIndex 作为切割线，[startIndex, i] 就是要截取的子串；如果子串是回文，则继续递归，否则剪枝

  - 判断回文：使用动态规划，事先一次性计算出, 针对一个字符串`s`, 它的任何子串是否是回文字串, 然后在我们的回溯函数中直接查询即可
    - `dp[i][j]` : i 到 j 是否是回文字符串





### 子集问题

一个N个数的集合里有多少符合条件的子集

如果把 子集问题、组合问题、分割问题 都抽象为一棵树的话，**那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点**



LeetCode 78、子集

- 描述节点的状态有：当前选择的组合和 startIndex
- 不需要剪枝，**子集就是要遍历整棵树**



LeetCode 90、子集 2

- 和 78 类似，区别就是集合里有重复元素了，而且求取的子集要去重
- 树层去重：**必须要先排序**，在 for 循环里和前一个元素做比较



#### 排列问题

N个数按一定规则全排列，有几种排列方式

- 排列是有顺序的，每层都是从 0 开始搜索而不是 startIndex
- 需要used数组记录path里都放了哪些元素了



LeetCode 46、全排列

- 利用约束条件「不能重复选」，做剪枝，剪去不会产生正确解的选项（分支）
  - 利用 hashMap，记录选过的数，下次遇到相同的数，跳过。
  - 这样就不会进入「不会得出解的分支」，不做无效的搜索。
- 为什么要回溯：当一个递归调用结束，结束的是当前的递归分支，还要去别的分支继续搜；所以要撤销当前的选择，回到选择前的状态，再选下一个选项，即进入下一个分支



LeetCode 47、全排列 II

- 和 46 类似，区别在与给定一个可包含重复数字的序列，要返回所有不重复的全排列，需要去重
- **去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**
- 通过 used数组记录path里都放了哪些元素了，与前一个节点比较来去重





### 其他

LeetCode 79、单词搜索

- for 循环遍历矩阵，找到起点
- 递归逻辑：起点可能不止一个，基于其中一个`S`，看看能否找出剩下的`"EE"`路径，下一个字符`E`有四个可选点：当前点的上、下、左、右，逐渐尝试
- 剪枝：
  - 当前的点，越出矩阵边界
  - 当前的点，之前访问过，不满足「同一个单元格内的字母不允许被重复使用」：用一个二维矩阵 used，记录已经访问过的点，下次再选择访问这个点，就直接返回 false。
  - 当前的点，不是目标点，比如你想找 E，却来到了 D
- 回溯：这里暗含回溯
  - 有的选点是错的，选它就构建不出目标路径，不能继续选。要撤销这个选择，去尝试别的选择。
  - 只要其中有一个递归调用返回 true，`||`后的递归就不会执行，即找到解就终止搜索，利用`||`的短路效应，把枝剪了。


```
// canFindRest 表示：基于当前选择的点[row,col]，能否找到剩余字符的路径。
// 如果 canFindRest 是 false，说明基于当前点不能找到剩下的路径，所以当前递归要返回false，还要回溯 used
const canFindRest =
      canFind(row + 1, col, i + 1) ||
      canFind(row - 1, col, i + 1) ||
      canFind(row, col + 1, i + 1) ||
      canFind(row, col - 1, i + 1)
```





LeetCode 79、岛屿数量

- 扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索，最终岛屿的数量就是我们进行深度优先搜索的次数。
- 在深度优先搜索的过程中，每个搜索到的值都会被标记，标记过的值不需要再次搜索
