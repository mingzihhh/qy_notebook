LeetCode 54、螺旋矩阵

- 一轮迭代：每遍历一条边，下一条边遍历的起点被“挤占”，要更新相应的边界，一轮迭代完遍历内圈
  - 用 top，bottom，left，right 表示边界，通过改变对应值缩小边界
- 最后一圈可能是剩下的单行或单列，需要单独判断 break



LeetCode 56、合并区间

- **将区间按照左端点升序排序**
- 将第一个区间加入 `merged` 数组中，并按顺序依次考虑之后的每个区间，比较前一个区间右端点和当前区间左端点是否重合



LeetCode 189、轮转数组

- 轮转 *n* 次等于没有轮转，轮转 *n*+1 等于轮转 1 次，依此类推，轮转 *k* 次等于轮转 k%n 次
- 先翻转整个数组，再翻转 [0, k%n ] 区间的元素，再翻转 [k%n, n-1 ] 区间的元素



LeetCode 238、除自身以外数组的乘积

- 前缀积 * 后缀积：
  - 对于给定索引 `i`，`L[i]` 代表的是 `i` 左侧所有数字的乘积，`R[i]` 代表的是 `i` 右侧所有数字的乘积。
  - L[i] = L[i-1] * nums[i-1]，L[0] = 1；R[i] = R[i+1] * nums[i+1]，R[length - 1] = 1； 
  - 索引 `i` 处的值为：`L[i] * R[i]`
- 优化空间：用输出数组记录 L[i]，用变量在遍历时动态跟踪右边元素的乘积



LeetCode 415、字符串相加

- 指针 i 指向 num1 末尾数字，指针 j 指向 num2 末尾数字，i j 数字相加，用 carry 记录进位
- 若遍历过程中，num1 或 num2 当前已无数字（长度不同），用 0 补位



LeetCode 43、字符串相乘

- 如果有一个数是 0，则直接返回 0

- 创建一个 `resultArr` 数组，用于存储每一位的计算结果，长度为 `len1 + len2`，这可以容纳最大可能的结果

- 使用双重循环遍历 `num1` 和 `num2` 的每一位，计算它们的乘积，与进位累加到 `resultArr` 的相应位置`resultArr[i + j + 1]`；使用进位处理，将下一个进位加到前一位`resultArr[i + j]`。
- 将结果数组转换成字符串，去掉没有用到的前导零



LCR 105. 岛屿的最大面积

- **DFS**，遇到 1 就深搜计算面积，计算过程中标记已访问的岛屿，赋值为 -1，避免重复访问；每计算完一个面积就更新一次最大面积



LeetCode 88、合并有序数组

- **倒序遍历**，两个指针分别指向两个数组末尾，用 tail 指向合并后的数组末尾
- 先比较较大的数，把大的数放到数组nums1的后面；如果先从较小的数比较，则nums1的元素可能发生移位后挪，时间复杂度高一些。
- 取小的元素赋给 nums1[tail] ，被选的那个数组，它的指针左移，另一个数组的指针不动，tail 指针左移，准备安排下一个



LeetCode 240、搜索二维矩阵 2

- 从右上角开始比较，大于 target 时向左移动 col，小于 target 时向下移动 row

