LeetCode 217、存在重复元素

- 对于数组中每个元素，我们将它插入到 set 中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。



LeetCode 349、两个数组的交集

- 先使用 set 对数组去重，再直接根据哈希判断是否存在



LeetCode 1、两数之和

- 用  hashMap 存储遍历过的元素和对应的索引，每遍历一个元素，看看  hashMap 中是否存在满足要求的目标数字

  

LeetCode 219、存在重复元素II

- 用  hashMap 存储遍历过的元素和对应的索引，每遍历一个元素，看看  hashMap 中是否存在满足要求的目标数字

  

LeetCode 205、同构字符串

- 判断 *s* 和 *t* 每个位置上的字符是否都一一对应

- 维护两张 hashMap，分别记录 s2t 和 t2s 的对应关系，从左至右遍历两个字符串的字符，不断更新两张哈希表，没有冲突就是同构的

  

LeetCode 242、有效的字母异位词

- 简单：字符串排序后再比较，相同则为 true

- 使用 hash：使用数组模拟 hashMap，长度 26，记录每个字母的出现频次



LeetCode 49、字母异位词分组

- 需要**将字符串排序再比较**，这样就不用管字符相同但是乱序的情况
- 如果把 aab,aba,baa 按照字母从小到大排序，我们可以得到同一个字符串 aab。而对于每种字母出现次数不同于 aab 的字符串，例如 abb 和 bab，排序后为 abb，不等于 aab。所以当且仅当两个字符串排序后一样，这两个字符串才能分到同一组。

- 用哈希表来分组，把排序后的字符串当作 key，原字符串组成的列表（即答案）当作 value，最后把所有 value 加到一个列表中返回。



LeetCode 128、最长连续序列

- 排序：O(nlogn)
  - 从小到大排序

  - 遍历数组，比较相邻的两项，如果相同，则跳过，继续遍历下一项

  - 如果当前项+1 等于下一项，说明遇到连续项，count +1。否则，说明连续情况发生中断，将 count 重置为 1

- Set：O(n)
  - 先使用 set 去重
  - **每个数都判断一次这个数是不是连续序列的开头那个数** => 如果当前项 - 1存在于 set ，说明当前项不是连续序列的起点，跳过，继续遍历
  - 不断在 set 中查看 cur + 1 是否存在，存在，则 count +1



LeetCode 387、字符串中的第一个唯一字符

- 使用 hashMap 记录每个字母的出现频次 / 位置

- 如何判断第一个

  - 可以重新遍历字符串，第一个满足条件则返回
  - 如果在 hashMap 中记录位置，记录完遍历 hashMap 的 value 挨个比较

  



LeetCode 409、最长回文串

-  用哈希表统计每个字符的个数，每满2，则res+2； 如果最后s.size() > res，说明其中有的字符为奇数个数，res = res + 1;



LeetCode 409、快乐数

- 用哈希表记录出现过的数字，如果一个数字重复出现说明有无限循环
