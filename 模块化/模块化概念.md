## 模块化和传输

### 模块

`package`，逻辑上相关的代码组织到同一个包内，隔离、组织复杂的JavaScript代码，我们称为模块化。

一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。

模块化可以帮助开发者在不影响全局命名空间的前提下管理代码，便于**功能分离、代码复用和依赖管理**。

- 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
- 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信

- 解决模块命名冲突，文件依赖的问题。



### 模块化的好处

- 避免命名冲突(减少命名空间污染)

- 更好的分离, 按需加载

- 更高复用性

- 高可维护性

  

### 模块化进化过程

- **全局function模式 : 将不同的功能封装成不同的全局函数**

  - 函数一个功能就是实现特定逻辑的一组语句打包。

  - 缺点：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

- **namespace模式 : 简单对象封装**

  - 把所有的模块成员封装在一个对象中。减少全局遍历，避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系。
  - 缺点：外部可以随意修改内部成员，安全问题

  ```
  var myModule = {
      var1: 1,
  
      var2: 2,
  
      fn1: function(){
  
      },
  
      fn2: function(){
  
      }
  }
  ```

- **IIFE模式：匿名函数自调用(闭包)**

  - 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
  - 作用: 数据是私有的, 外部只能通过暴露的方法操作
  - 问题: 如果当前这个模块依赖另一个模块怎么办?

- **IIFE模式增强 : 引入依赖**

  - 现代模块实现的基石

  - **保证模块的独立性，还使得模块之间的依赖关系变得明显**。

    ```
    // module.js文件
    (function(window, $) {
      let data = 'www.baidu.com'
      //操作数据的函数
      function foo() {
        //用于暴露有函数
        console.log(`foo() ${data}`)
        $('body').css('background', 'red')
      }
      function bar() {
        //用于暴露有函数
        console.log(`bar() ${data}`)
        otherFun() //内部调用
      }
      function otherFun() {
        //内部私有的函数
        console.log('otherFun()')
      }
      //暴露行为
      window.myModule = { foo, bar }
    })(window, jQuery)
    
    
     // index.html文件
      <!-- 引入的js必须有一定顺序 -->
      <script type="text/javascript" src="jquery-1.10.1.js"></script>
      <script type="text/javascript" src="module.js"></script>
      <script type="text/javascript">
        myModule.foo()
      </script>
    ```

    

  



### 传输

模块要在浏览器端运行，所以他们必须要从server端传输到浏览器端。

- 一个模块对应一个请求

  - 优点：只有需要的模块被传输

  - 缺点：多个请求意味着更多的额外的开销；

    ​	　请求的延迟导致你的应用启动很慢

- 一个请求包含所有模块

  - 优点：更少的请求开销，更少的延迟
  - 缺点：不需要的模块也会被传输

- **分块传输**

  当编译所有模块时，将模块集分成多个较小的组(块)。这会使得多个请求更小、更快。

  初始化阶段不需要的模块组可以按需加载. 这样就可以加速初始加载，当你实际需要代码时也能加载更多的代码块。

  「分割点」取决于开发者