#### ES 和 CommonJS做对比

**加载时机**：

- CommonJS 模块是**运行时**加载，只有在 `require` 时才会解析并执行模块。
- ES6 模块是**编译时**确定的，在编译阶段就确定模块的依赖关系，输入和输出，运行时再实际执行。

CommonJS  中，当你 `require` 一个模块时，整个模块会立即被加载和执行，属于**同步加载**。导出的对象（即`module.exports`属性）是在模块的代码执行后确定的，可以动态加载和决定导出什么内容。

ES6 模块的依赖和导出内容在代码**编译阶段**就已经确定，它的对外接口只是一种静态定义，在代码静态解析阶段会生成一个只读引用，不是对象，所以模块本身没办法引用。

由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。



**导出行为**：

- CommonJS 导出的值是计算后的结果，即导出的对象在模块代码执行完后才生成，是**值的拷贝**（对于引用类型，导出的是引用的副本）。
- ES6 模块导出的内容是**值的引用**，值的变化会自动反映在导入模块中。

ES6 通过 `export` 导出的对象本身可以被修改，对于**导入者**来说，是否能够修改取决于导出的内容是**原始值**还是**引用类型**，原始值不能修改，引用（如对象、数组、函数等），导入的模块是可以修改这个对象的属性或内容的；可以使用 `Object.freeze` 可以防止导出的对象被修改。

如果要在commonjs中动态获取值，可以使用取值器函数



**动态性**：

- CommonJS 模块的 `require` 可以放在条件语句或函数中，因此具有较强的动态性。
- ES6 模块的 `import` 语句只能位于模块的顶层，不能放在函数或条件语句中，限制了动态导入。



CommonJS

```
// a.js
const value = Math.random();   // 每次运行都不一样
module.exports = { value };

// b.js
const a = require('./a');
console.log(a.value);  // 输出的是运行时的结果

```



ES6

```
// a.js
export const value = Math.random();  // 每次运行都不一样
export let count = 1;
setTimeout(() => count++, 1000);     // 1 秒后 count 增加

// b.js
import { value, count } from './a';
console.log(value);   // 输出的是编译时确定的 value
console.log(count);   // 输出的是 count 当前的引用值
setTimeout(() => console.log(count), 1500);  // 1.5 秒后输出最新的 count

```





#### **ES 和 CommonJS 分别是如何处理循环引用的？**

https://cloud.tencent.com/developer/article/2062326

ES 模块：使用一张**模块间的依赖地图**来解决死循环问题，已经进入过的模块标注为"获取中"，遇到import语句会去检查这个地图，已经标注为"获取中"的则不会进入，所以循环引用时不会再次进入。地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。

CommonJS ：通过**模块缓存**来解决，每一个模块都先加入缓存再执行，每次遇到require都先检查缓存，没有就把导出值加入缓存，有就直接取缓存，这样就不会出现死循环，借助缓存，输出的值也很简单就能找到了。

