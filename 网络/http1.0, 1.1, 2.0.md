## http1.0, 1.1, 2.0

<https://my729.github.io/blog/internetwork/http%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB.html#http1-0%E7%89%B9%E6%80%A7>

### http1.0 

- **无状态**：服务器不跟踪不记录请求过的状态

  - 对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录

- **无连接**：浏览器每次请求都需要建立tcp连接

  性能缺陷：

  **1. 无法复用连接**
  每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低

  **2. 队头阻塞**
  http1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的

### http1.1

- **长连接**：新增Connection字段，可以设置keep-alive值保持连接不断开

- **管道化**：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回（无法解决队头堵塞

- **缓存处理**：新增字段cache-control

- **断点传输**：在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率

  在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range

### http2.0

- **二进制分帧**：将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码

- **压缩头部**：相同头部发送一次，变化单独发送

- **多路复用**：在一条连接上，我可以同时发起无数个请求，并且响应可以同时返回。（不需要合并文件了

- **服务器推送**：服务器可以额外的向客户端推送资源，而无需客户端明确的请求（内嵌资源优化不需要



**多路复用**

**HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。**

基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来