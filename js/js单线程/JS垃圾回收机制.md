## JS 垃圾回收机制

**Javascript 具有自动垃圾回收机制，会定期对那些我们不再使用的变量、对象所占用的内存进行释放**

**全局变量**：生命周期会一直持续，直到页面卸载

**局部变量**：声明在函数中，它的声明周期从执行函数开始，直到函数执行结束。在这个过程中，局部变量会在堆或栈上被分配相应的空间以存储它们的值，函数执行结束，这些局部变量也不再被使用，它们所占用的空间也就被释放

**特殊情况**：局部变量被函数外部的变量所使用，其中一种情况就是**闭包**。因为在函数执行结束后，函数外部的变量依然指向函数内的局部变量，此时的局部变量依然在被使用，所以也就不能够被回收



### 垃圾回收的两种实现方式

#### 引用计数 （判断对象是否不再需要，很少使用）

统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收

优点：

- **实时回收**：引用计数可以在对象不再被引用时立即回收，不需要等待垃圾收集器的运行。这可以减少内存占用和提高程序的性能。
- 简单高效：引用计数是一种简单的垃圾收集算法，实现起来相对容易，不需要复杂的算法和数据结构。

缺点：

- 出现**循环引用**时，计数永远不为0，需要手动回收
- 计数开销：维护每个对象的引用计数需要占用额外的内存空间，而且每次添加、删除引用都需要更新计数，增加了额外的开销

```
function func () {
      let f = {}
      let g = {}
      f.prop = g
      g.prop = f
      // 由于 f 和 g 互相引用，计数永远不可能为 0
}
```



#### 标记清除（判断对象是否可以获得，常用）

**标记阶段**：

这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将**定期从根开始**，找所有从根开始引用的对象，然后找这些对象引用的对象，并对每个被访问到的对象打上标记……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

**清除阶段**：

在清除阶段，垃圾回收器会遍历整个内存，对于没有标记的对象，即被判定为垃圾的对象，会被立即回收，释放内存空间。这样，只有被标记的对象会被保留在内存中，而垃圾对象会被清除。

“有零引用的对象”总是不可获得的，但是相反却不一定

优点：

- 简单有效：标记清除算法相对简单，容易实现。它可以准确地找到不再被引用的对象，并回收内存。

- **解决"循环引用"的问题** => 从根对象无法查找到

缺点：

-  **垃圾回收过程中的停顿**：标记清除算法会暂停程序的执行，进行垃圾回收操作。当堆中对象较多时，可能会导致明显的停顿，影响用户体验。
- **内存碎片化**：标记清除算法会在回收过程中产生大量的不连续的、碎片化的内存空间。这可能导致后续的内存分配难以找到足够大的连续内存块，从而使得内存的利用率降低。



#### 标记整理

标记清除的增强操作，他在标记阶段的操作和标记清除一致，但是清除阶段会先执行整理，移动对象位置，对内存空间进行压缩。

增加**整理阶段**：清除之前将内存中的活动对象移动到一端，使得空闲空间连续，并且没有碎片化。

优点：

- **解决了标记清除算法的内存碎片化问题**，标记整理算法在清除阶段会将标记的对象整理到内存的一端，从而解决了标记清除算法产生的碎片化问题，使得内存空间得到更好的利用，减少了空间的浪费。

缺点：

- **垃圾回收过程中的停顿**：标记整理算法同样会暂停程序的执行，进行垃圾回收操作。当堆中对象较多时，可能会导致明显的停顿，影响用户体验。



#### 半空间收集器的变体Scavenge算法

**半空间收集器**：将内存空间划分为两个相等的区域 from space和to space，新对象首先被分配到From空间中，等from space区域满时将存活对象有序移动（Evacuation）到to space中（防止内存碎片的产生），角色交换，重复过程 。

**标记阶段**：从根对象（通常是全局对象）开始，通过引用关系进行遍历并标记所有活动对象。

**复制阶段**：将所有活动对象从From空间复制到To空间，并且进行排序，使得To空间成为连续的内存块。

**清除阶段**：对From空间进行清理，回收非活动对象所占用的内存空间。

**空间交换**：在清除阶段完成后，From空间和To空间的角色会发生交换，即From空间变为To空间，To空间变为From空间。这样，下一次的垃圾回收就可以在新的To空间中进行。



### V8 垃圾回收策略

https://juejin.cn/post/7274146202496090170?searchId=202410151553582083AE2A4D73C4306B03#heading-9

https://juejin.cn/post/6981588276356317214?searchId=202410151553582083AE2A4D73C4306B03#heading-7

V8的垃圾回收分为了副垃圾回收器和主垃圾回收器，进行**分代式垃圾回收**（young generation(nursery和intermediate) 、old generation），对不同代的对象采取不同的回收策略，从而提高垃圾回收的效率和性能。

**新生代：**存放的是存活时间较短的对象（经过一次垃圾回收后,就被释放回收掉），通常只支持 `1～8M` 的容量

**老年代：**存放的是存活时间较长的对象（经过多次垃圾回收后仍存在），通常比较大

满足条件时新生代对象可以【晋升】到老年代：

**年龄达到阈值**：每个对象都有一个年龄计数器，初始为0。每次经过一次垃圾回收，如果对象仍然存活，它的年龄计数器就会加1。当年龄计数器达到阈值时，对象就会被晋升到老生代内存。

**To空间的内存占用达到一定比例**：当To空间的内存占用超过一定比例（通常是25%到50%）时，也会触发对象的晋升。这是为了避免新生代内存过快地被填满，导致频繁的垃圾回收。



回收方式：

- **副垃圾回收器**处理新生代，采用Scavenge垃圾回收算法，通过将内存分为两个半空间来进行垃圾回收，优化了对象的分配和回收过程
- **主垃圾回收器**处理老年代，通过标记清除和标记整理两种垃圾回收策略配合使用，通过对整个堆进行标记和整理，以减少内存的碎片化，提高内存利用率。



优点：分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率



#### 优化策略

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做**全停顿（Stop-The-World）**。

优化方式：

- 副垃圾回收器：采用的就是**并行回收**策略，它在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域。由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针。

- 主垃圾回收器：

  - 首先主垃圾回收器主要使用**并发标记**，在主线程执行 JavaScript时，辅助线程就开始执行标记操作了，所以**标记是在辅助线程中完成的**。

  - 标记完成之后，再执行**并行**整理和清理操作。主线程在执行整理和清理操作时，多个辅助线程也在执行整理整理和清理操作。

  - 另外，主垃圾回收器还采用了**增量回收**的方式，整理和清理的任务会穿插在各种 JavaScript 任务之间执行。这样，垃圾回收和应用程序的执行**交替进行**，减少了单次标记的时间，从而降低了对应用程序的阻塞时间。

    - 怎样才能做到垃圾回收器随时暂停和重启，并且在重启的时候恢复到上一步执行的地方呢？ => **三色标记法**
    - 标记好的数据若是在暂停垃圾回收的过程中被修改了如何处理？=> **写屏障**

  - V8采用的是**惰性清理(Lazy Sweeping)**，采用这种延迟清理的原因是因为在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就延迟了清理，让JS代码先执行，或者**只清理部分垃圾**，而不清理全部。

    

### 内存泄漏

本质上讲, 内存泄漏就是不再被需要的内存, 由于某种原因, 无法被释放，会导致内存空间越占越多，导致程序卡顿甚至司机

可能造成内存泄漏的原因：

1. 忘记解除事件监听

2. 未销毁的定时器

3. 没有合理使用闭包

4. DOM引用 

   使用WeakMap或者WeakSet存储DOM节点，DOM被移除掉后，WeakMap或者WeakSet内部的DOM引用会被自动回收清除
   
5. 全局对象出现循环引用