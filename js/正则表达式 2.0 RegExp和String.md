## 正则表达式 2.0 RegExp和String

### 一、RegExp

##### RegExp实例属性

可以用来获知一个正则表达式的各方面信息

- global：是否全局搜索，默认是false
- ignoreCase：是否大小写敏感，默认是false
- multiline：多行搜索，默认值是false
- lastIndex：是当前表达式模式首次匹配内容中最后一个字符的下一个位置，每次正则表达式成功匹配时，lastIndex属性值都会随之改变
- source：正则表达式的文本字符串

##### RegExp实例方法

- **test()**

  用于测试字符串参数中是否存正则表达式模式，如果存在则返回true，否则返回false;

  经常用在if语句中

- **exec()**

  用于正则表达式模式在字符串中运行查找，如果`exec()`找到了匹配的文本，则返回一个结果数组,否则返回 null

  除了数组元素和length属性之外，`exec()`方法返回对象还包括两个属性。

  1. index 属性声明的是匹配文本的**第一个**字符的位置
  2. input 属性则存放的是被检索的字符串string

**非全局调用**

调用**非全局**的RegExp对象的`exec()`时，返回数组的第一个元素是与正则表达式相匹配的文本，第二个元素是与 RegExpObject的第一个子表达式相匹配的文本（如果有的话），第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有的话），以此类推

**全局调用**（flag:g)

调用全局的RegExp对象的`exec()`时，它会在RegExp实例的`lastIndex`属性指定的字符处开始检索字符串string

1. 当`exec()`找到了与表达式相匹配的文本时，在匹配后，它将把RegExp实例的`lastIndex`属性设置为匹配文本的最后一个字符的下一个位置。可以通过反复调用exec()方法来遍历字符串中的所有匹配文本
2. 当 exec() 再也找不到匹配的文本时，它将返回null，并把lastIndex属性重置为`0`



### 二、String

- **match()**

  match()方法将检索字符串，以找到一个或多个与regexp匹配的文本。但regexp是否具有标志 g对结果影响很大。

  ##### 非全局调用

  如果regexp没有标志`g`，那么match()方法就只能在字符串中执行**一次匹配**。如果没有找到任何匹配的文本，match() 将返回null。否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。

  该数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性

  1. index 属性声明的是匹配文本的起始字符在字符串中的位置
  2. input 属性声明的是对 stringObject 的引用

  ##### 全局调用

  如果regexp具有标志`g`则match()方法将执行全局检索，**找到字符串中的所有匹配子字符串**

  若没有找到任何匹配的子串，则返回 null。如果找到了一个或多个匹配子串，则返回一个数组

  不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是字符串中所有的匹配子串，而且也没有`index`属性或`input`属性。

- **replace(reg, replaceStr)**

  第一个参数可以传入RegExp对象，传入正则表达式可以使replace方法更加强大灵活

  如果replace方法的第一个参数传入的是带分组的正则表达式，我们在第二个参数中可以使用`$1...$9`来获取相应分组内容，比如希望把字符串 `1<%2%>34<%567%>89` 的`<%x%>`换为`$#x#$`，我们可以这样

  ```
  '1<%2%>34<%567%>89'.replace(/<%(\d+)%>/g,'@#$1#@');
  //"1@#2#@34@#567#@89"
  ```



- **replace(reg, function)**

- **split(reg)**

  一些复杂的分割情况下我们可以使用正则表达式