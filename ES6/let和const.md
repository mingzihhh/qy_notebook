## let 

块级作用域，不存在变量提升，不允许在相同作用域内，重复声明同一个变量

块作用域由 { } 包括，if语句和 for语句里面的{ }也属于块作用域。

---

什么是暂存性死区？

ES6 规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为

在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

---

为什么需要块级作用域？

不合理，如：内层变量可能会覆盖外层变量；用来计数的循环变量泄露为全局变量

块级作用域可以任意嵌套，外层作用域无法读取内层作用域的变量。内层作用域可以定义外层作用域的同名变量。

在块级作用域之中声明函数，之外不可引用；只在使用大括号的情况下成立；环境导致的行为差异太大，应该避免在块级作用域内声明函数。

---

## const

一个只读的常量。一旦声明，常量的值就不能改变。

`const`一旦声明变量，就必须立即初始化，不能留到以后赋值，否则报错

块级作用域，不提升，存在暂时性死区，不可重复声明。

实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。

![1552272229660](C:\Users\QY\AppData\Roaming\Typora\typora-user-images\1552272229660.png)

---

声明变量：var,function,let,const,import,class

---

顶层对象，在浏览器环境指的是`window`对象，在 Node 指的是`global`对象。

ES5 之中，顶层对象的属性与全局变量是等价的。

ES6 中，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。