## const，var和let

#### const

- 块级作用域
- 相同作用域内，不能重新声明（var和let也不行），不能重名。
- const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是**变量标识符不能重新分配**。声明一个基本类型的时候为常量，不可修改；声明对象可以修改
- 暂存死区，无变量提升

暂时死区，就是不能声明之前使用变量。暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

#### let

- 块级作用域

- 相同作用域内，不能重新声明（var和let也不行），不能重名。

- 暂存死区，无变量提升

  

  https://zhuanlan.zhihu.com/p/28140450

  1. let 的「创建」过程被提升了，但是初始化没有提升。

  2. var 的「创建」和「初始化」都被提升了。

  3. function 的「创建」「初始化」和「赋值」都被提升了。

  4.  const 只有「创建」和「初始化」，没有「赋值」过程。

     ![img](https://pic1.zhimg.com/80/v2-9c8c4a0a3ce5402b1a74f488d79c74d0_hd.jpg)

`for`循环的特别之处：设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

#### var

   ES5 中作用域有：全局作用域、函数作用域。没有块作用域的概念。

- 没有块的概念，可以跨块访问, 不能跨函数访问
- 在函数中定义为函数作用域，否则定义在全局作用域，全局作用域的变量实际上被绑定到`window`的一个属性
- 可以变量提升



函数作用域：创建函数后在花括号中声明的一些语句或变量只在当前函数中起作用。

块级作用域：ES6带来的新特性，在语句块中声明的语句或变量只在当前语句块中起作用，不如 if () { }; while ( ) { } ...

**为什么需要块级作用域？**

- 防止内部变量覆盖外部变量
- 用来计数的循环变量泄露为全局变量。

