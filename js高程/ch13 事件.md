## 事件

### 事件和事件流

事件是用户或浏览器自身执行的一些动作，比如点击、鼠标移动。

**JavaScript 和 HTML的交互是通过事件实现的。**

当一个事件发生以后，它会在不同的DOM节点之间传播（propagation）。这种传播分为三个阶段：

##### **重点关注事件冒泡**

第一阶段：从window对象传导到目标节点，称为“**捕获阶段**”(capture phase)。如果目标的任何一个祖先专门注册了事件监听函数，那么在事件传播的过程中就会运行这些函数。

第二阶段：在目标节点上触发，称为“**目标阶段**”(target phase)。直接注册在目标上的适合的事件监听函数将运行。

第三阶段：从目标节点传导回window对象，称为“**冒泡阶段**”(bubbling phase)。

这种三阶段的传播模型，会使得一个事件在多个节点上触发。

事件在DOM中的执行顺序为：外层捕获事件→内层捕获事件→先注册的目标事件→后注册的目标事件→内层冒泡事件→外层冒泡事件

Opera、Firefox、Chrome、Safari都支持DOM事件流，IE不支持事件流，只支持事件冒泡



### 事件处理程序

- ##### html内联方式

  this等于事件的目标元素


- ##### 通过JS指定：将一个函数赋值给一个事件处理程序属性

  this引用当前元素，属性值设为null，可以删除事件处理程序


- ##### DOM2：addEventListener和removeEventListener

  this引用当前元素，执行顺序与添加顺序相同

  参数：

  1. 事件类型

  2. 事件处理方法

  3. 布尔参数，如果是true表示在捕获阶段调用事件处理程序，如果是false，则是在事件冒泡阶段处理，默认false

- ##### IE：attachEvent()和detachEvent()

  this等于window，执行顺序与添加顺序相反

  参数：

  1. 事件处理程序名称
  2. 事件处理方法

- ##### 跨浏览器：addHandler()和removeHandler()

  视情况添加或移除事件处理程序


onclick是内联事件（Inline Events），由于内联事件是作为元素属性保存起来的，这些属性可以被覆盖，所以如果为同一个事件绑定了多个处理程序，那么最后一个处理程序会覆盖之前的程序；

addEventListener是事件监听器（Event Listeners），理论上可以为一个元素绑定无数个事件，实际应用中则决定于客户端的电脑内存以及浏览器。另一个重要特性，则是addEventListener的最后一个参数，用来控制监听器对于冒泡事件的响应。95%的使用场景中，这个参数都为 false，attachEvent 以及内联事件则都没有可以实现相同功能的这个参数。



### 事件对象

在触发DOM上的某个事件的时候会产生一个事件对象**event**，这个对象包含着所有与事件有关的信息，包括产生事件的元素、事件类型等相关信息。所有浏览器都支持event对象，但支持方式不同。

- ##### dom中的事件对象

  兼容DOM的浏览器会产生一个event对象传入事件处理程序中。

  在事件处理程序内部，this始终等同于currentTarget，而target是事件的实际目标。

  区别：

  **currentTarget始终是监听事件者，而target是事件的真正发出者**。

  常用属性：

  | **属性/方法**     | 类型     | 读写 | 说明                                           |
  | ----------------- | -------- | ---- | ---------------------------------------------- |
  | preventDefault()  | Function | 只读 | 取消事件默认行为                               |
  | stopPropagation() | Function | 只读 | 取消事件进一步捕获或冒泡                       |
  | target            | Element  | 只读 | 事件的目标元素                                 |
  | type              | String   | 只读 | 被触发的事件类型，用于通过一个函数处理多个事件 |

- event.stopImmediatePropagation(）和 event.stopPropagation()

  如果有多个相同类型事件的事件监听函数绑定到同一个元素，当该类型的事件触发时，它们会按照被添加的顺序执行。如果其中某个监听函数执行了 `event.stopImmediatePropagation()`方法，则当前元素剩下的监听函数将不会被执行。
  
- ##### IE中的事件对象

  访问IE中的event对象有几种不同的方式，取决于指定事件处理程序的方法。直接为DOM元素添加事件处理程序时，event对象作为window对象的一个属性存在



### 事件委托

利用事件冒泡，解决"事件处理程序过多"的问题，可以减少内存损耗，动态绑定事件。

一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。



https://www.jianshu.com/p/1eb41968c8e3

https://segmentfault.com/a/1190000005759243

https://zhuanlan.zhihu.com/p/26536815